---
layout: post
title: Kakfa生产者
tag: Kafka
---

## 生产者API
```java
import org.apache.kafka.clients.producer.KafkaProducer;
import org.apache.kafka.clients.producer.Producer;
import org.apache.kafka.clients.producer.ProducerRecord;

import java.util.Properties;


public class ProducerMain {

    public static void main(String[] args) {
        Properties props = new Properties();
        props.put("bootstrap.servers", "10.4.121.218:9092");
        /**
         * acks 控制着认定请求已经完成的标准，all是最慢却最耐用的设置
         */
        props.put("acks", "all");
        /**
         * 如果请求失败了，生产者可以自动重新发送请求的次数
         */
        props.put("retries", 0);
        /**
         * 生产者为每一个partition还没发送出去的记录设置一个缓存区，此配置设置了缓存区的大小，
         * 调大参数会导致更大的批处理，但是需要更多的内存，因为会为每一个激活的partition创建
         * 这么大的缓存区
         */
        props.put("batch.size", 16384);
        /**
         * 默认情况下，即使缓存区中还有空间，也可以立即发送请求。如果要减少请求次数，可以设置
         * linger.ms > 0，这样生产者再发送请求之前会等待该毫秒数，希望有更多的记录被添加到缓
         * 存区以填满这个批次的缓存。但是如果1ms之后，仍然没有记录被添加进来，每个请求就会白
         * 白增加1ms的延迟。所以在高负载下，可以用一小部分延迟来换取更少、但更高效的请求。另
         * 外，即便linger.ms = 0，在一段时间内到达的记录也是会被同一批次处 理的
         */
        props.put("linger.ms", 1);
        /**
         * 生产者可以使用的缓存空间的总量。当请求的发送速度比请求发送到服务器的速度还快，那么缓
         * 存空间很快就会被耗尽，这时其他的请求就会被阻塞。阻塞的时长由max.block.ms决定，如果
         * 阻塞的时间超过max.block.ms的值，会抛出TimeoutException
         */
        props.put("buffer.memory", 33554432);
        /**
         * serializer指定了如何将ProducerRecord的键值对对象转换成字节。可以使用
         * ByteArraySerializer 或者 StringSerializer
         */
        props.put("key.serializer", "org.apache.kafka.common.serialization.StringSerializer");
        props.put("value.serializer", "org.apache.kafka.common.serialization.StringSerializer");

        /**
         * 生产者包含一个缓冲池，它保存还未传送到集群上的记录，以及一个后台I/O线程，负责将记录转
         * 换成请求，并将其传输到集群。使用后没能正常关闭生产者会泄露缓冲池中的资源。
         */
        Producer<String, String> producer = new KafkaProducer<String, String>(props);

        for (int i = 0; i < 100; i++) {
            /**
             *  send()方法是异步的，调用时会将记录添加到待处理记录的缓冲池中，然后立即返回
             *  这使得生产者可以对缓冲池中的各个记录进行批处理，从而提高效率
             */
            producer.send(new ProducerRecord<String, String>("my-topic", Integer.toString(i)));
        }
        producer.close();
    }
    
}
```