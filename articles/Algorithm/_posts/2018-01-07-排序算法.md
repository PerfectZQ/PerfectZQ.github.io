---
layout: post
title: 排序算法
tag:  Algorithm
---
## 排序算法概括
排序算法宏观上可以分成两类：**非线性时间比较类排序**和**线性时间非比较类排序**。从这两个分类的名字可以看出，非比较类的排序算法在耗时上是优于比较类的排序算法的，其实它是典型的空间换时间。实际选用什么排序算法，就需要自行考量了。

下面这张图更加详细的概括了各种排序算法：
![有帮助的截图]({{ site.url }}/assets/各排序算法.png)

## 比较类排序
### 冒泡排序
核心思想：从第一个元素开始，紧靠着的元素两两比较，如果左边的元素大于右边的元素，则交换位置。每次循环都把本次循环最大的数交换到末尾，直到没有可以交换的元素为止。

例如有一组数：`[6,1,3,5,4,2]`，交换流程如下
```console
# 第一次循环
1, 3, 5, 4, 2, 6
# 第二次循环
1, 3, 4, 2, 5, 6
# 第三次循环
1, 3, 2, 4, 5, 6
# 第四次循环
1, 2, 3, 4, 5, 6
# 第五次循环
no swap, stop
```

冒泡排序最好的情况，数据正序排列，时间复杂度`O(n)`，只需冒泡比较一遍即可，不需要交换。

最差情况，数据逆序排列，时间复杂度`O(n2)`，需要冒泡比较`n`遍，每次需要交换`n-i`次。

Java实现
```java
public class BubbleSort {
    public static void sort(int[] arr) {
        for (int i = 1; i <= arr.length; i++) {
            // 如果一次循环中没有发生元素交换，则证明排序完毕
            boolean isStop = true;
            for (int j = 0; j < arr.length - i; j++) {
                if (arr[j] > arr[j + 1]) {
                    isStop = false;
                    int temp = arr[j];
                    arr[j] = arr[j + 1];
                    arr[j + 1] = temp;
                }
            }
            if (isStop) {
                System.out.println("no swap, stop");
                break;
            }
            // 输出当次循环结果
            for (int num : arr) {
                System.out.print(num + " ");
            }
            System.out.println();
        }
    }

    public static void main(String[] args) {
        int[] arr = {6, 1, 3, 5, 4, 2};
        sort(arr);

    }
}
```
### 快速排序
冒泡排序比较相邻元素大小的方式会导致总的交换次数太多，快速排序采用分治的思想改进冒泡排序。

原理：从待排序的`n`个元素中任选一个元素(通常是选第一个)，作为分区标准元素，如果分区标准右面的元素小于标准元素，两元素交换位置，如果分区标准左面的元素大于标准元素，两元素交换位置，直到标准元素左边的元素都小于标准元素，右面的元素都大于标准元素。结束第一轮循环。然后对标准元素分割出来的两个子序列递归执行前面的循环。

