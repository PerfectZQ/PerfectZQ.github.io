---
layout: post
title: 挖掘频繁模式与关联关系
tag: Machine Learning
---
<script src="https://cdnjs.cloudflare.com/ajax/libs/mathjax/2.7.0/MathJax.js?config=TeX-AMS-MML_HTMLorMML" type="text/javascript"></script>

## 概念

　　**频繁模式**：模式可分为项集、子序列。假设数据库中有100条交易记录，其中80条交易记录中都包含牛奶和面包。牛奶和面包的组合就称为`项集`，频繁出现在数据库记录中的项集，就称为`频繁项集`。而如果项集是有先后顺序的，如先购买 PC 再购买键盘，那么 PC 和键盘的组合就称为`子序列`，同理频繁出现在数据库中的子序列就是`频繁子序列`。频繁项集和频繁子序列统称为频繁模式。

　　**关联规则**：在项集`A={面包,牛奶}`中，买面包的人也会买牛奶就是一对关联关系，关联关系表示为`面包=>牛奶[support=60%,confidence=80%]`。其中`support`是支持度，`confidence`是置信度。

　　**支持度**：在所有交易记录中，包含面包和牛奶的交易记录占交易记录总数的百分比，即 \\(P( 面包 \cup 牛奶 ) \\) 。

　　**置信度**：在所有交易记录中，包含面包的情况下包含牛奶的概率，即 \\( P( 牛奶 \| 面包 ) = \frac{ P( 面包 \cup 牛奶 ) }{ P( 面包 ) } \\)

　　**最小支持度阈值**：支持度超过最小支持度阈值的项集称为`频繁项集`。 

　　**最小置信度阈值**：满足最小支持度和最小置信度的关联规则成为`强关联规则`。

　　对于频繁项集挖掘，如果最小支持度计数设置的过小的话，会导致频繁项集过多，导致计算机无法处理。因为`一个频繁项集的子集肯定也是频繁项集`。一个长度为100的频繁项集，就会产生\\(C_{100}^{1}\\)个频繁一项集，\\(C_{100}^{2}\\)个频繁二项集... \\(C_{100}^{1} + C_{100}^{2} + ... + C_{100}^{100} = 2^{100}-1 \approx 1.27 * 10^{30} \\)个频繁子项集。因此提出了`闭频繁项集`和`极大频繁项集`的概念。

　　**闭频繁项集**：对于项集X和项集Y，如果X是Y的真子集，不存在真超项集Y和项集X的支持度计数相等。那么称项集X是`闭的`，如果项集X是频繁项集，则X称为闭频繁项集。

　　**极大频繁项集**：对于频繁项集X，X是Y的子集，不存在超项集Y是频繁项集，那么项集X称为极大频繁项集。

## Apriori
　　先验算法是发现频繁项集的最基本的算法，它通过限制候选产生发现频繁项集。
### 算法思想
　　先找出数据库中的所有频繁一项集`L1`，然后通过`L1`找出频繁二项集`L2`，以此类推，直到无法找到频繁k项集。
### 先验性质
　　**先验性质**：频繁项集的所有非空子集也一定是频繁的。对于一个非频繁项集I，添加项A到这个项集中，结果集\\(I \cup A\\)不可能比I更频繁，因此结果集也一定是非频繁的。
### 算法过程
　　找出每一个`Lk`就需要对数据库进行一次完整的扫描，但是基于先验性质可以压缩搜索空间。为了找出`Lk`，首先将`Lk-1`与自身连接产生候选k项集的集合。为了有效实现，Apriori算法默假定项集中的项是按字典顺序排好序的。这样，如果两个项集中的前`k-2`项是相同的，其他不同，则这两个项集是可连接的。例如，为了找出`L4`，项集`{I1,I2,I3}`和项集`{I1,I2,I4}`连接，产生的候选项集就是`{I1,I2,I3,I4}`。得到的候选项集不一定是频繁的，因此还需要扫描数据库，统计候选项集的支持度技术，确定是否是频繁项集，如果不是就凑候选项集集合中剔除。