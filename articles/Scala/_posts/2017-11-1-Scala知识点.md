---
layout: post
title: Scala知识点整理
tag: Scala
---
## 目录
* TOC
{:toc}

## 变量
　　scala中包含两种类型的变量：可变变量和不可变变量。分别用`var`和`val`定义。

　　可变变量就和java中的对象变量一样，变量被赋值之后仍然随着程序的运行而改变。
```scala
var str = "abc"
str = "def"
```
　　而不可变变量就相当于java中被final修饰的变量，一旦被赋值就不可以再修改。
```scala
val str = "abc"
// 不能再修改它的值！会报错
str = "def"
```
　　编译报错：
```console
Error:(43, 7) reassignment to val
  sum = "edf"
```
　　**需要特别注意的是：scala中的变量在定义的时候必须初始化赋值。无论是可变还是不可变变量**

　　可变变量在初始化时可以使用占位符`_`，会给不同类型的对象赋上默认的初始值
```scala
var str:String = _
str:String = null

var in:Int = _
in:Int = 0

var flo:Float = _
flo:Float = 0.0

var c:Char = _
c:Char = ?
```
### lazy 变量
　　scala中的**不可变变量**可以用`lazy`关键字修饰，这样变量只有在真正被使用的时候才会赋值。
```scala
// 普通变量，定义时就已经赋值
val test1 = "test1"
test1: String = test1

// lazy修饰，定义时没有被赋值
lazy val test2 = "test2"
test2: String = <lazy>

// 使用时会被赋值
test2
res0: String = test2
```
　　**需要注意的是：`lazy`只能修饰`val`类型的变量，不能用于`var`，主要是为了避免程序运行中变量还未使用便被重新赋值。**
　　


## 数据类型
### 基本数据类型
　　Scala的基本数据类型和基本Java一致，但是首字母必须大写，因为Scala中的所有值类型都是对象：Byte、Short、Int、Long、Float、Double、Char、Boolean
```scala
val a:Int = 1;
// 可以直接使用对象的方法
println(a.toString)
// 也可以这样~
println(1.toString)
```
### String类型
　　scala中定义的String类型实际上就是java.lang.String类型，因此可以调用java中String类型的所有方法

　　除此之外，也可以调用以下方法。这些方法在java中是不存在的，实际上scala会将String类型对象阻焊换成StringOps类型对象，在遇到reverse、map、drop、slice方法调用时编译器会自动进行隐式转换
```scala
val s = "hello"
// 反转符
println(s.reverse)
// 丢弃字符 (丢弃前n个字符)
println(s.drop(3))
// 获取一定范围内的子串， 左开右闭[1,4)
println(s.slice(1, 4))
```
　　对于包含需要转义的字符的字符串，除了添加转移符`\`外，还可以使用三个双引号将字符串包裹起来。这样就可以原样输出字符串中的内容。
```scala
println("""hello world \n""")
// 原样输出：hello world \n
```
　　但是在使用`split()`或者`replace()`等函数内部使用正则表达式的方法时需要额外注意，需要添加额外的转义符。详细原因请参考我的这篇文章：[特殊字符处理异常]({% post_url 2017-07-20-split()和replace()方法特殊字符的处理 %})
### 对象比较运算
　　scala中的对象比较和java中的对象比较不同，scala是基于内容比较，而java是依据对象引用比较（即对象的物理内存地址是否一样）。基于内容比较是scala的重要特点之一
```scala
val s1 = new String("abc");
val s2 = new String("abc");
// 结果是true
println(s1 == s2) 
// 在scala中String的equals方法和==相同
println(s1.equals(s2)) 
// 如果想比较内存地址（引用）是否为是相同的，可以使用eq方法。返回false
println(s1.eq(s2))
```
### 元组类型
　　元组是Scala的一种特殊类型，它是不同类型值的聚集，将不同类型的值放在一个变量中保存。
```scala
// 一个三元组
val tuple = ("hello", "world", 1)
// 访问元组
println(tuple._1 + "," + tuple._2 + "," + tuple._3)
// 使用时还可以提取元组的内容到变量中
val (a, b, c) = tuple
// 访问元组
println(a + "," + b)
```
　　在函数中表示一个参数是二元组类型：
```scala
def tupleString2Int(tuple2: (String, String)): (Int, Int) = (tuple2._1.toInt, tuple2._2.toInt)

tupleString2Int(("1", "2"))
```
### 符号类型
　　符号类型主要起标识作用，常用于模式匹配、内容判断中。符号类型(Symbol) 定义时需要`'`(单引号)符号
```scala
// 定义一个符号类型的变量s，变量s会被默认识别为Symbol类型
val s = 'start
// 显示声明符号类型
val s_ : Symbol = 'start
// 符号类型主要起标识作用，常用与模式匹配、内容判断中
// for example
if (s == s_) println(true) // 使用 == 来比较变量时，比较的是变量的内容而非引用
else println(false)
// 直接输出符号类型的变量会按原样输出
println("s = " + s)
```
## 集合
　　scala中的集合分两种：可变和不可变。可变集合可以被更新或修改，增删改操作会作用与原集合对象。而不可变集合是不可以被更新或修改的，增删改会导致生成新的集合对象，原集合对象没有任何变化。

　　在不导入任何包的情况下，scala会默认自动导入下面的包：
```scala
import java.lang._
import scala._
import Predf._
```
　　而Predef对象中包含了Set、Map等定义
```scala
type Map[A, +B] = immutable.Map[A, B]
type Set[A]     = immutable.Set[A]
val Map         = immutable.Map
val Set         = immutable.Set
```
　　因此scala默认导入的包是不可变集合，`scala.collection.immutable`，想要使用可变集合就要手动导入`scala.collection.mutable`包中的可变集合。

　　mutable和immutable包中常用的可变集合和不可变集合的对应关系表如下：
| 可变(mutable) | 不可变(immutable) |
| :-------- | :-------- |
| ArrayBuffer、ArraySeq | Array |
| ListBuffer、MutableList | List |
| LinkedList、DoubleLinkedList | / |
| Queue | / |
| Stack | Stack |
| HashMap | HashMap |
| HashSet | HashSet |
| ArrayStack |  |

### 数组(Array)

### 列表(List)

### 集合(Set)

### 映射(Map)

### 队列(Queue)

### 栈(Stack)

## 函数
　　一个scala函数：
```scala
def gcd(x:Int, y:Int):Int = {
  if(x % y == 0)
    y // 函数的返回值
  else
    gcd(y, x % y) // 函数的返回值
}
```
　　其中`def`是函数声明，`gcd`是函数名称，`x:Int`和`y:Int`是Int类型的函数形参，最后的`:Int`是函数返回值类型。`=`后的花括号包含的是函数体，**当函数体只有一行的时候可以省略掉{}**。函数中的最后一条执行语句为函数的返回值，返回值可以加`return`关键字，也可以不加。

　　scala的函数还有类型推导功能，如果不写函数返回值类型，会根据最终的返回值推导出函数的返回值类型。
```scala
def sum(x:Int, y:Int) = x + y
```
　　类型推导有两个限制：
1. 如果函数中存在递归调用，则必须显示的指定函数的返回值类型，不能省略，否则编译报错。
![有帮助的截图]({{ site.url }}/assets/scala_fuction_error1.PNG)
2. 如果使用`return`指定返回值，则必须显示指定函数的返回值类型，不能省略，否则编译报错。
![有帮助的截图]({{ site.url }}/assets/scala_fuction_error2.PNG)

### 值函数（函数字面量）
　　scala中函数也是对象，可以赋值给变量，这种函数称为值函数或函数字面量。
```scala
val sum = (x:Int, y:Int) => { x + y }
```
　　其中`sum`是变量名(函数名)，`(x:Int, y:Int)`是函数参数，`=>`是函数映射符，`{}`中的内容是函数体，同理如果只有一行可以省略。

　　像`(x:Int, y:Int) => { x + y }`这样的表达式被称为Lambda表达式，因此值函数也被称为Lambda函数或者匿名函数。

　　值函数不能像正常函数一样指定返回值类型，只能用类型推导的方式确定返回值类型，因此函数体中也不可以包含关键字`return`.
```scala
//  值函数不能在参数后面指定返回值类型
val sum = (x:Int,y:Int):Int=>x+y
```
　　编译报错：
```console
Error:(42, 37) not found: type +
  val sum = (x:Int, y:Int):Int => x + y
Error:(42, 14) not found: value x
  val sum = (x:Int, y:Int):Int => x + y
Error:(42, 21) not found: value y
  val sum = (x:Int, y:Int):Int => x + y
```

　　调用函数和使用普通函数一样，例如：`sum(1, 2)`。

　　值函数可以跟一般的val变量一样使用`lazy`关键字修饰，只有当程序真正使用到该函数字面量的时候才会被创建。

　　值函数最常用的场景是作为高阶函数的输入参数，例如我们常用的`map()`
```scala
def map[B](f: (A) => B):Array[B]
```
　　其中 `f` 就是值函数，输入参数只有一个，类型为`A`，返回值类型是`B`，其中`B`是泛型。

　　例如将数组中的各个元素都加1
```scala
// 定义一个值函数，作用于数组中的每一个元素
val arr = Array(1, 2, 3, 4)
val increment1 = (x:Int) => { x + 1 }
val resultArr = arr.map(increment1)
```
　　而在实际使用中值函数一般都只使用一次，直接用匿名函数作为参数。
```scala
val arr = Array(1, 2, 3, 4)
val resultArr = arr.map((x:Int) => { x + 1 })
```
　　scala语法博大精深，在实际使用中也不用这么麻烦，写这么多代码，可以将其简化，下面就逐步讲解神(cao)奇(dan)的语法糖：
```scala
// 因为arr是Int类型的数组，使用map的时候可以通过类型推断得知它的输入类型是Int，因此可以将输入参数的类型省略
arr.map((x) => { x + 1 })

// 当值函数的输入参数只有一个的时候，可以将()省略，map函数的输入参数一定是一个。
arr.map(x => { x + 1 })

// => 右面只有一句表达式，所以{}也可以省略了
arr.map(x => x + 1)

// 对于值函数， => 左面的输入参数 x 在 => 右面只出现过一次，因此可以用占位符 _ 代替
arr.map(_ + 1)
```
　　需要注意的是：`arr.map(_+1)`合法是因为arr是Int类型的可以推断出`_`的类型。但是单独声明值函数就会出错，例如：
```scala
// val increment = (x:Int) => {1 + x} 的简写
val increment = 1 + _
```
　　即便有`1 +`这种表达式，但是还不足让编译器推断出准确的类型，因为`_`还有可能是String类型，这时就需要指定明确的类型。
```scala
val increment = 1 + (_:Int)
```
　　或者指定`increment`的具体类型，输入参数是Int类型，返回值是Int类型。这样也可以。
```scala
val increment:(Int) => Int = 1 + _
```
### 高阶函数


### 函数柯里化

