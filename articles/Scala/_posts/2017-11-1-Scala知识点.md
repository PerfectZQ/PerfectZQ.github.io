---
layout: post
title: Scala知识点整理
tag: Scala
---

## 变量
　　scala中包含两种类型的变量：可变变量和不可变变量。分别用`var`和`val`定义。

　　可变变量就和java中的对象变量一样，变量被赋值之后仍然随着程序的运行而改变。
```scala
var str = "abc"
str = "def"
```
　　而不可变变量就相当于java中被final修饰的变量，一旦被赋值就不可以再修改。
```scala
val str = "abc"
// 不能再修改它的值！会报错
str = "def"
```
　　编译报错：
```console
Error:(43, 7) reassignment to val
  sum = "edf"
```
　　**需要特别注意的是：scala中的变量在定义的时候必须初始化赋值。无论是可变还是不可变变量**

　　可变变量在初始化时可以使用占位符`_`，会给不同类型的对象赋上默认的初始值
```scala
var str:String = _
str:String = null

var in:Int = _
in:Int = 0

var flo:Float = _
flo:Float = 0.0

var c:Char = _
c:Char = ?
```
### lazy 变量
　　scala中的**不可变变量**可以用`lazy`关键字修饰，这样变量只有在真正被使用的时候才会赋值。
```scala
// 普通变量，定义时就已经赋值
val test1 = "test1"
test1: String = test1

// lazy修饰，定义时没有被赋值
lazy val test2 = "test2"
test2: String = <lazy>

// 使用时会被赋值
test2
res0: String = test2
```
　　**需要注意的是：`lazy`只能修饰`val`类型的变量，不能用于`var`，主要是为了避免程序运行中变量还未使用便被重新赋值。**
　　


## 数据类型
　　scala万物皆对象，包括数字、函数，与java存在很大的不同。下面介绍一些重要的类。

　　scala中`Any`类是所有类的超类。它有两个子类`AnyRef`和`AnyVal`。其中`AnyRef`是所有引用类型的基类，`AnyVal`是直接类型(例如`Int`、`Double`)的基类。

　　`Any`是一个抽象类，它有如下方法：!=()、==()、asInstanceOf()、equals()、hashCode()、isInstanceOf()和toString()。`AnyVal`没有更多的方法了。`AnyRef`则包含了Java的Object类的一些方法，比如notify()、wait()和finalize()。

　　`AnyRef`是可以直接当做java的`Object`来用的。对于`Any`和`AnyVal`，只有在编译的时候，scala才会将它们视为`Object`。换句话说，在编译阶段`Any`和`AnyVal`会被类型擦除为`Object`。

　　`Nothing`是所有对象的子类，是一个类。`null`是所有对象的默认值，是一个特殊的独立的概念（null不是对象），是一个特殊的唯一的值。
### 基本数据类型
　　Scala的基本数据类型和基本Java一致，但是首字母必须大写，因为Scala中的所有值类型都是对象：Byte、Short、Int、Long、Float、Double、Char、Boolean
```scala
val a:Int = 1;
// 可以直接使用对象的方法
println(a.toString)
// 也可以这样~
println(1.toString)
```
### String类型
　　scala中定义的String类型实际上就是java.lang.String类型，因此可以调用java中String类型的所有方法

　　除此之外，也可以调用以下方法。这些方法在java中是不存在的，实际上scala会将String类型对象阻焊换成StringOps类型对象，在遇到reverse、map、drop、slice方法调用时编译器会自动进行隐式转换
```scala
val s = "hello"
// 反转符
println(s.reverse)
// 丢弃字符 (丢弃前n个字符)
println(s.drop(3))
// 获取一定范围内的子串， 左开右闭[1,4)
println(s.slice(1, 4))
```
　　对于包含需要转义的字符的字符串，除了添加转移符`\`外，还可以使用三个双引号将字符串包裹起来。这样就可以原样输出字符串中的内容。
```scala
println("""hello world \n""")
// 原样输出：hello world \n
```
　　但是在使用`split()`或者`replace()`等函数内部使用正则表达式的方法时需要额外注意，需要添加额外的转义符。详细原因请参考我的这篇文章：[特殊字符处理异常]({% post_url 2017-07-20-split()和replace()方法特殊字符的处理 %})
### 对象比较运算
　　scala中的对象比较和java中的对象比较不同，scala是基于内容比较，而java是依据对象引用比较（即对象的物理内存地址是否一样）。基于内容比较是scala的重要特点之一
```scala
val s1 = new String("abc");
val s2 = new String("abc");
// 结果是true
println(s1 == s2) 
// 在scala中String的equals方法和==相同
println(s1.equals(s2)) 
// 如果想比较内存地址（引用）是否为是相同的，可以使用eq方法。返回false
println(s1.eq(s2))
```
### 元组类型
　　元组是Scala的一种特殊类型，它是不同类型值的聚集，将不同类型的值放在一个变量中保存。
```scala
// 一个三元组
val tuple = ("hello", "world", 1)
// 访问元组
println(tuple._1 + "," + tuple._2 + "," + tuple._3)
// 使用时还可以提取元组的内容到变量中
val (a, b, c) = tuple
// 访问元组
println(a + "," + b)
```
　　在函数中表示一个参数是二元组类型：
```scala
def tupleString2Int(tuple2: (String, String)): (Int, Int) = (tuple2._1.toInt, tuple2._2.toInt)

tupleString2Int(("1", "2"))
```
### 符号类型
　　符号类型主要起标识作用，常用于模式匹配、内容判断中。符号类型(Symbol) 定义时需要`'`(单引号)符号
```scala
// 定义一个符号类型的变量s，变量s会被默认识别为Symbol类型
val s = 'start
// 显示声明符号类型
val s_ : Symbol = 'start
// 符号类型主要起标识作用，常用与模式匹配、内容判断中
// for example
if (s == s_) println(true) // 使用 == 来比较变量时，比较的是变量的内容而非引用
else println(false)
// 直接输出符号类型的变量会按原样输出
println("s = " + s)
```
## 集合
　　scala中的集合分两种：可变和不可变。可变集合可以被更新或修改，增删改操作会作用与原集合对象。而不可变集合是不可以被更新或修改的，增删改会导致生成新的集合对象，原集合对象没有任何变化。

　　在不导入任何包的情况下，scala会默认自动导入下面的包：
```scala
import java.lang._
import scala._
import Predf._
```
　　而Predef对象中包含了Set、Map等定义
```scala
type Map[A, +B] = immutable.Map[A, B]
type Set[A]     = immutable.Set[A]
val Map         = immutable.Map
val Set         = immutable.Set
```
　　因此scala默认导入的包是不可变集合，`scala.collection.immutable`，想要使用可变集合就要手动导入`scala.collection.mutable`包中的可变集合。

　　mutable和immutable包中常用的可变集合和不可变集合的对应关系表如下：

| 可变(mutable) | 不可变(immutable) |
| :-------- | :-------- |
| ArrayBuffer、ArraySeq | Array |
| ListBuffer、MutableList | List |
| LinkedList、DoubleLinkedList | / |
| Queue | / |
| Stack | Stack |
| HashMap | HashMap |
| HashSet | HashSet |
| ArrayStack |  |

### 数组(Array)

### 列表(List)

### 集合(Set)

### 映射(Map)

### 队列(Queue)

### 栈(Stack)

## 函数
　　一个scala函数：
```scala
def gcd(x:Int, y:Int):Int = {
  if(x % y == 0)
    y // 函数的返回值
  else
    gcd(y, x % y) // 函数的返回值
}
```
　　其中`def`是函数声明，`gcd`是函数名称，`x:Int`和`y:Int`是Int类型的函数形参，最后的`:Int`是函数返回值类型。`=`后的花括号包含的是函数体，**当函数体只有一行的时候可以省略掉{}**。函数中的最后一条执行语句为函数的返回值，返回值可以加`return`关键字，也可以不加。

　　scala的函数还有类型推导功能，如果不写函数返回值类型，会根据最终的返回值推导出函数的返回值类型。
```scala
def sum(x:Int, y:Int) = x + y
```
　　类型推导有两个限制：
1. 如果函数中存在递归调用，则必须显示的指定函数的返回值类型，不能省略，否则编译报错。
![有帮助的截图]({{ site.url }}/assets/scala_fuction_error1.PNG)
2. 如果使用`return`指定返回值，则必须显示指定函数的返回值类型，不能省略，否则编译报错。
![有帮助的截图]({{ site.url }}/assets/scala_fuction_error2.PNG)

### 值函数（函数字面量）
　　scala中函数也是对象，可以赋值给变量，这种函数称为值函数或函数字面量。
```scala
val sum = (x:Int, y:Int) => { x + y }
```
　　其中`sum`是变量名(函数名)，`(x:Int, y:Int)`是函数参数，`=>`是函数映射符，`{}`中的内容是函数体，同理如果只有一行可以省略。

　　像`(x:Int, y:Int) => { x + y }`这样的表达式被称为Lambda表达式，因此值函数也被称为Lambda函数或者匿名函数。

　　值函数不能像正常函数一样指定返回值类型，只能用类型推导的方式确定返回值类型，因此函数体中也不可以包含关键字`return`.
```scala
//  值函数不能在参数后面指定返回值类型
val sum = (x:Int,y:Int):Int=>x+y
```
　　编译报错：
```console
Error:(42, 37) not found: type +
  val sum = (x:Int, y:Int):Int => x + y
Error:(42, 14) not found: value x
  val sum = (x:Int, y:Int):Int => x + y
Error:(42, 21) not found: value y
  val sum = (x:Int, y:Int):Int => x + y
```

　　调用函数和使用普通函数一样，例如：`sum(1, 2)`。

　　值函数可以跟一般的val变量一样使用`lazy`关键字修饰，只有当程序真正使用到该函数字面量的时候才会被创建。

　　值函数最常用的场景是作为高阶函数的输入参数，例如我们常用的`map()`
```scala
def map[B](f: (A) => B):Array[B]
```
　　其中 `f` 就是值函数，输入参数只有一个，类型为`A`，返回值类型是`B`，其中`B`是泛型。

　　例如将数组中的各个元素都加1
```scala
// 定义一个值函数，作用于数组中的每一个元素
val arr = Array(1, 2, 3, 4)
val increment1 = (x:Int) => { x + 1 }
val resultArr = arr.map(increment1)
```
　　而在实际使用中值函数一般都只使用一次，直接用匿名函数作为参数。
```scala
val arr = Array(1, 2, 3, 4)
val resultArr = arr.map((x:Int) => { x + 1 })
```
　　scala语法博大精深，在实际使用中也不用这么麻烦，写这么多代码，可以将其简化，下面就逐步讲解神(cao)奇(dan)的语法糖：
```scala
// 因为arr是Int类型的数组，使用map的时候可以通过类型推断得知它的输入类型是Int，因此可以将输入参数的类型省略
arr.map((x) => { x + 1 })

// 在调用函数时，如果只有一个参数，可以用花括号`{}`来替代小括号`()`。map函数只有一个参数。
arr.map {
  (x) => { x + 1 }
}

// 在定义函数时，如果函数的输入参数只有一个，可以将()省略，map函数的参数是函数类型，这个函数的输入参数是一个。
arr.map {
  x => { x + 1 }
}

// => 右面只有一句表达式，所以{}也可以省略了
arr.map {
  x => x + 1
}

// 对于值函数， => 左面的输入参数 x 在 => 右面只出现过一次，因此可以用占位符 _ 代替
arr.map {
  _ + 1
}


```
　　需要注意的是：`arr.map(_+1)`合法是因为arr是Int类型的可以推断出`_`的类型。但是单独声明值函数就会出错，例如：
```scala
// val increment = (x:Int) => {1 + x} 的简写
val increment = 1 + _
```
　　即便有`1 +`这种表达式，但是还不足让编译器推断出准确的类型，因为`_`还有可能是String类型，这时就需要指定明确的类型。
```scala
val increment = 1 + (_:Int)
```
　　或者指定`increment`的具体类型，输入参数是Int类型，返回值是Int类型。这样也可以。
```scala
val increment:(Int) => Int = 1 + _
```
### 高阶函数
　　**一个函数的输入参数中有函数类型的参数**，或者**返回值的类型是函数类型**，那么这个函数就是**高阶函数**。

　　输入参数是函数类型的
```scala
def higherOrderFunction(f: (Double) => Double) = {
    f(1)
}
```

　　返回值是函数类型的
```scala
def higherOrderFunction(factor: Int): (Double) => Double = {
    (x: Double) => factor * x
  }
```

　　常见高阶函数的使用：其中A是调用函数的迭代对象的元素的类型，例如:`Array(1,2).map()`，调用函数的迭代对象是`Array[Int]`，所以`A`是`Int`类型。 

1. map() 将函数`f`应用于调用`map()`的可迭代对象的每一个元素，返回新的可迭代对象。

```scala
// Array的map函数定义
def map[B](f: (A) => B): Array[B]

// Array类型的map函数
Array("kafka","sparkstreaming","elasticsearch").map(_*2)

// List类型的map函数
List("kafka", "sparkstreaming", "elasticsearch").map((_, 1))

// Map类型的map函数
Map("kafka" -> 1, "sparkstreaming" -> 2, "elasticsearch" -> 3).map(_._1)
```
2. flatMap() 将函数`f`应用于调用`flatMap()`的可迭代对象的每一个元素，每一个元素会转换成相应的集合`GenTraverableOnce[B]`，最后将得到的所有集合扁平化，返回一个新的可迭代对象。

```scala
// Array的flatMap函数定义
def flatMap[B](f: (A) => GenTraversableOnce[B]): Array[B]

// flatMap的使用
Array("Hello world", "This is John Snow").flatMap(
    sentence => {
      val words: Array[String] = sentence.split("")
      val statistics: Array[(String, Int)] = words.map(word => {
        (word, 1)
      })
      statistics
    })

// 简写
Array("Hello world", "This is John Snow").flatMap { _.split(" ").map((_, 1)) }
```
3. filter() 返回所有满足条件`p`的元素

```scala
// Array的filter函数定义
def filter(p: (T) => Boolean): Array[T]

// filter的使用，返回大于3的元素
Array(1, 5, 7, 3, 4).filter(_ > 3)
```
4. reduce() 使用`op`作用于集合之上，返回结果类型为`A1`。`op`是特定的联合二元算子(associative binary operator)，`A1`为`A`的超类。

```scala
// Array的reduce函数定义
def reduce[A1 >: A](op: (A1, A1) => A1): A1

// reduce的使用，结果是10
Array(1, 2, 3, 4).reduce((x1, x2) => {
    println(s"x1 = ${x1}, x2 = ${x2}")
    x1 + x2
  })
// 输出结果
// x1 = 1, x2 = 2
// x1 = 3, x2 = 3
// x1 = 6, x2 = 4


// 简写
Array(1, 2, 3, 4).reduce(_ + _)

/**
* reduce还有两个变种，reduceLeft()、reduceRight()。
* reduceLeft()和reduce()一样，op函数按照集合中元素的顺序从左到右进行reduce操作，
* 而reduceRight()作用顺序相反。
* 只要记住left就是取元素的顺序和x1、x2的赋值顺序都是从左往右，
* 计算结果也是先从左开始赋值(x1)，right就全部反过来就可以了。
*/
Array(1, 2, 3, 4).reduceRight((x1, x2) => {
    println(s"x1 = ${x1}, x2 = ${x2}")
    x1 + x2
  })
// 输出结果
// x1 = 3, x2 = 4
// x1 = 2, x2 = 7
// x1 = 1, x2 = 9
```
5. fold() 使用联合二元算子对集合进行fold操作，`z`为给定的初始值。和reduce差不多，区别就是有初始值`z`

```scala
// Array的fold函数定义
def fold[A1 >: A](z: A1)(op: (A1, A1) => A1): A1

// fold的使用，结果是10
Array(1, 2, 3, 4).fold(0)((x1, x2) => {
    println(s"x1 = ${x1}, x2 = ${x2}")
    x1 + x2
  })
// 输出结果
// x1 = 0, x2 = 1
// x1 = 1, x2 = 2
// x1 = 3, x2 = 3
// x1 = 6, x2 = 4

// 简写
Array(1, 2, 3, 4).fold(0)(_ + _)

/**
* fold同样也有两个变种，foldLeft()、foldRight()。
* foldLeft()和fold()一样，op函数按照集合中元素的顺序从左到右进行fold操作，
* 而foldRight()作用顺序相反
*/
Array(1, 2, 3, 4).foldRight(0)((x1, x2) => {
    println(s"x1 = ${x1}, x2 = ${x2}")
    x1 + x2
  })
// 输出结果
// x1 = 4, x2 = 0
// x1 = 3, x2 = 4
// x1 = 2, x2 = 7
// x1 = 1, x2 = 9
```
### 闭包
　　"An Object is data with functions.A Closure is a function with data" —— Jon D. Cook

　　闭包是由函数和运行时的数据决定的，也可以理解为函数和上下文。
```scala
// 自由变量(上下文)，在运行中随时可能发生变化
var factor = 2
// 函数
val f = (x:Int) => x * factor

f(2) // 得到结果 4

factor = 3

f(2) // 得到结果6
```

　　自由变量factor在程序运行时随时可能发生变化，它处于一个开放的状态。但是执行函数`f`时，就临时确定了自由变量`factor`的值，自由变量就暂时处于一个封闭的状态，这种存在从开放到封闭过程的函数就称为闭包。

　　高阶函数也可以理解为闭包，例如：
```scala
def higherOrderdFunction(f:Double => Double) = {
  println(f(1.7))
}

// 向上取整
val f1 = (x:Double) => Math.ceil(x)
// 向下取整
val f2 = (x:Double) => Math.floor(x)

higherOrderdFunction(f1) // 结果是2.0
higherOrderdFunction(f2) // 结果是1.0
```
　　可见 `f` 就是自由变量(上下文)，函数在运行时传入的参数不一样得到的结果也是不一样的，因此高阶函数也是一种闭包(closure)。
### 函数柯里化
　　一个返回值类型是函数类型的高阶函数：
```scala
def higherOrderFunction(factor: Int): (Double) => Double = {
    (x: Double) => factor * x
  }
```

　　用下面的方式调用这个函数：
```scala
higherOrderFunction(3)(5.0) // 结果是 15.0

// 实际调用过程是下面的样子。
val f = higherOrderFunction(3) // f = (x: Double) => 3 * x
f(5.0) // 结果 15.0 
```

　　这种调用方式合并的函数调用方式与柯里化函数十分相似，柯里化函数的定义是这个样子的。
```scala
def curryMultiply(factor: Int)(x: Double) = factor * x
// 调用
curryMultiply(3)(5.0) // 结果是15.0

// 例如 hbase的scan方法
def scan(tableName:String, cf:String, startRow:String, stopRow:String)(processFn:(Result)=>Unit) = {...}

// 在调用时如果参数只有一个时，可以用花括号{}代替小括号()
scan(t1, cf, startRow, stopRow){ r =>  
   //TODO process result  
}  
```
　　需要注意的是:**柯里化函数和高阶函数不同，curryMultiply(3)并不能返回一个函数对象，需要写上所有的柯里化参数。**

　　如果想让柯里化的函数生成新的函数，就需要下一节的**部分应用函数(partially applied function)**

### 部分应用函数
　　让柯里化函数生成部分应用函数。
```scala
val part = curryMultiply(3)_
part(5.0) // 结果是15.0

// 注意函数名和 _ 之间有空格
val part2 = curryMultiply _
part2(3)(5.0)
```
　　其中`part`是`(Double) => Double`类型的函数，`part2`是`(Int) => (Double => Double)`类型的函数。`part2`就可以像高阶函数一样来返回函数对象了。

　　不只是柯里化函数可以转为部分应用函数，普通的函数也可以。
```scala
def price(x1: Double, x2: Double, x3: Double): Double = {
  x1 + x2 * x3
}

// 一个参数的部分应用函数，返回一个 Double => Double 类型的函数
def price_1 = price(_:Double, 699.0, 0.7)
// 调用
price_1(18.0)

// 两个参数的部分应用函数，返回一个 (Double, Double) => Double 类型的函数
def price_2 = price(_:Double, _:Double, 0.7)
// 调用
price_2(18.0, 699.0)

// 两个参数的部分应用函数，返回一个 (Double, Double, Double) => Double 类型的函数
def price_3 = price(_:Double, _:Double, _:Double)
// 调用
price_3(18.0, 699.0, 0.7)

// 等价与 price_3
def price_4 = price _
```
### 偏函数
　　离散数学中，函数的概念主要是限制了关系概念中的一对多，但是允许多对一。即在函数`y = f(x)`中 `x0、x1、x2`可以对应同一个`y`值，但是一个`x`值只能对应一个`y`值，不可以对应多个`y`值。

　　如果所有的`x`值，在`y = f(x)`函数中都能找到对应的`y`值，那么这个函数就是 **全函数**，如果存在某个`x`找不到对应的`y`值，那么这个函数就是 **偏函数**。

　　scala中的偏函数定义为`trait PartialFunction[-A, +B] extends (A => B)`。其中泛型`A`是片函数的输入参数类型，泛型`B`是偏函数的返回结果类型。偏函数只处理参数定义域的子集，对于子集外的参数会抛出异常，这一特点与scala模式匹配的特点吻合。

```scala
// 定义一个偏函数，只处理偶数值的参数
val isEven:PartialFunction[Int, String] = {
    case x if x % 2 == 0 => x + "is even"
  }

// 对于定义域子集外的参数会抛出异常
isEven(11)
/*
Caused by: scala.MatchError: 11 (of class java.lang.Integer)
	at scala.PartialFunction$$anon$1.apply(PartialFunction.scala:253)
	at scala.PartialFunction$$anon$1.apply(PartialFunction.scala:251)
	at com.zq.scala.函数.部分应用函数$$anonfun$2.applyOrElse(部分应用函数.scala:41)
	at com.zq.scala.函数.部分应用函数$$anonfun$2.applyOrElse(部分应用函数.scala:41)
	at scala.runtime.AbstractPartialFunction.apply(AbstractPartialFunction.scala:36)
	at com.zq.scala.函数.部分应用函数$.<init>(部分应用函数.scala:45)
	at com.zq.scala.函数.部分应用函数$.<clinit>(部分应用函数.scala)
	... 1 more
*/

// 除了定义一个变量是PartialFunction[Int, String]类型的，还可以直接定义函数
def partial: PartialFunction[Any, Unit] = {
    case x: Int => println("Int")
    case x: String = > println ("String")
  }
```
## 类与对象
　　scala底层还是用的jvm，所以scala类文件也会被编译成java字节码文件，逻辑上可以理解为将scala代码转换成相应的java代码来执行。
### 定义一个类
```scala
class Person {
  // 声明一个成员变量，scala中的成员变量在声明时必须要初始化，可以使用占位符。如果在定义时确实不需要初始化，则需要将类定义为抽象类。
  var name:String = null
}
```

　　上面的代码就相当于java的下列这些代码，scala会自动添加下面的方法。
```java
class Person {
    // 虽然成员变量在scala中声明时并没有添加private关键字，但实际上转换成字节码时是private的
    // 因此要访问name只能通过下面public的name()和name_$eq(String name)方法
    private String name = null;
    
    // 默认构造方法
    public Person() {}
    
    // getter方法
    public String name() { 
        return this.name;
    }
    
    /**
     * setter方法
     * name_$eq(java.lang.String)等同于name_=(java.lang.String)
     * 这是因为字节码的字符限制问题导致的
     */
    public void name_$eq(String name) {
        this.name = name;
    }
}
```

　　如果成员变量定义为`val`
```scala
class Person {
  // 声明一个成员变量，scala中的成员变量在声明时必须要初始化，可以使用占位符。如果在定义时确实不需要初始化，则需要将类定义为抽象类。
  val name:String = null
}
```

　　就会转换成下面的样子，与`var`相比，会发现成员变量被`final`修饰，而且少了setter方法
```java
class Person {
    // 虽然成员变量在scala中声明时并没有添加private关键字，但实际上转换成java字节码时是private的
    private final String name = null;
    
    // 默认构造方法
    public Person() {}
    
    // getter方法
    public String name() { 
        return this.name;
    }
}
```

　　如果声明成员变量是用`private`关键词修饰时，生成的setter和getter方法也是`private`的，这样就限定了成员只能在类中访问。
```scala
class Person {
  private var name:String = null
}
```

　　相当于
```java
class Person {
    private String name = null;
    
    // 默认构造方法
    public Person() {}
    
    // getter方法
    private String name() { 
        return this.name;
    }
    
    // setter方法
    private void name_$eq(String name) {
        this.name = name;
    }
}
```
### 创建对象
　　同java一样，使用关键字`new`你的对象。
```scala
val girlFriend = new Female("xx")

// 对于无参的构造函数，可以省略()
val singleDog = new Dog
```

### 类成员的访问
　　对于`var`定义的类成员变量，通过自动生成的getter、setter方法来访问类成员。
```scala
person = new Person
// 显式调用setter
person.name_$eq("zhangsan")

// getter
val name = person.name

// 隐式调用setter
person.name = "lisi"
```
　　看完隐式调用setter，你可能发现了一个问题，生成的字节码文件中的name是被关键字`private`修饰的，为什么可以直接访问name呢？因为实际上Scala底层依然是调用的`name_$eq(String name)`方法，而它是public的，只不过编译器的开发人员将这些细节屏蔽掉了。像这种调用者不知道是直接对成员变量进行访问，还是通过`setter`进行访问的方式称为*统一访问原则*

　　默认生成的setter和getter是scala风格的，如果想生成java风格的setter和getter，需要使用注解`@BeanProperty`

```scala
import scala.beans.BeanProperty
class Person{
  @BeanProperty var name:String = null
}
```
　　相当于下面的代码，可以看到除了生成scala风格的getter和setter，还会生成java风格的getter和setter

```java
class Person {
    private String name = null;
    
    // 默认构造方法
    public Person() {}
    
    // scala风格的getter方法
    public String name() { 
        return this.name;
    }
    
    // scala风格的setter方法
    public void name_$eq(String name) {
        this.name = name;
    }
    
    // java风格的getter方法
    public String getName() { 
        return this.name;
    }
    
    // java风格的setter方法
    public void setName(String name) {
        this.name = name;
    }    
}
```
### 单例对象 object
　　实际应用中，常常存在不创建对象就可以访问相应的成员变量或方法的场景，java使用关键字`static`来实现这个场景。而scala并没有关键字`static`，它使用单例对象(object)来实现这个场景。
```scala
object Person {
  private var num:Int = _
  def increment() = { num += 1 }
}

// 不需要创建对象，通过单例对象名称就可以直接访问其成员方法了
Person.increment()
```

　　转换成字节码反编译成java代码可以看到`increment()`被关键字`static`修饰。

### 应用程序对象
　　在java程序中，只要类中定义了`public static void main(String[] args)`方法的类就是程序执行的入口。在scala中同样也是使用`main`函数作为程序的入口，但是`main`方法只能定义在单例对象(object)中，定义了`main`方法的单例对象就成为应用程序对象(App)。
```scala
object Main {
    def main(args: Array[String]): Unit = {
        var num = 1
        println(num)
    }
}
```

　　除了手动定义`main`方法，还可以通过混入特质(trait)App来定义应用程序对象，这样在对象中可以直接写执行代码，使得代码更简洁，但是所有的局部变量(本来在main方法中声明的变量)会变成object的成员变量。
```scala
object Main extends App{
   var num = 1
   println(num)
}
```

### 伴生对象(Companion Object)和伴生类(Companion Class)
　　伴生类和伴生对象区别于其他类或者对象的最主要的地方就是控制访问权限。
```scala
// 伴生类
class Student {
  private var name:String = null
  def getStudentNo = {
    Student.incrementNo()
    // 伴生类中可以直接访问伴生对象Student的私有成员studentNo
    Student.studentNo
  }
}

// 伴生对象
object Student {
  private var studentNo:Int = 0
  def incrementNo() = {
    studentNo += 1
  }
  // 伴生对象中可以直接访问伴生类中的私有成员name
  def printName() = println(new Student().name)
}
```

　　上面的代码可以看出，伴生类与伴生对象互相开放了成员的访问权限。除此之外，伴生类和伴生对象还可以实现无new的方式创建对象。例如创建一个Array
```scala
val arr = Array(1, 2, 3, 4, 5)

// 其实它调用的是伴生对象Array中的apply方法
object Array extends FallbackArrayBuilding {
  /** Creates an array of `Int` objects */
  // Subject to a compiler optimization in Cleanup, see above.
  def apply(x: Int, xs: Int*): Array[Int] = {
    val array = new Array[Int](xs.length + 1)
    array(0) = x
    var i = 1
    for (x <- xs.iterator) { array(i) = x; i += 1 }
    array
  }
}
```

　　亲自实现一个
```scala
// 伴生类
class Student {
  private var name:String = null
}

// 伴生对象
object Student {
  private var studentNo:Int = 0
  def incrementNo() = {
    studentNo += 1
  }
  // apply方法，当使执行Student()时就会调用伴生对象的apply()方法，类似与构造方法。
  def apply: Student = new Student()
}
```

### 主构造函数
　　主构造函数的定义:
```scala
// 如果不写 var 默认成员变量是 val 的
class Student(var name:String, var age:Int) {
  // 类体中的执行代码会在构造函数中执行。
  println("this is construct method")
}
```

　　上面的代码就相当于下面的java代码，看完你就会发现scala的代码是有多简洁了。
```java
class Student{
    private String name;
    private int age;
    
    public String getName(){
        return name;
    }
    
    public void setName(String name){
        this.name = name;
    }

    public int getAge(){
        return age;
    }
    
    public void setAge(int age){
        this.age = age;
    }
    
    public Student(String name, int age){
        System.out.println("this is construct method");
        this.name = name;
        this.age = age;   
    }
}
```

　　主构造函数可以为参数提供默认值，这样创建对象的时候就可以不指定使用默认值的参数了。
```scala
class Student(var name:String, var age:Int = 18)

// age 使用默认值 18
new Student("zhangsan")
```

　　通过`private`关键字将构造函数私有化，这样就只能在类内部使用构造函数。
```scala
class Student private(var name: String, var age: Int)
```
### 辅助构造函数
　　当一个类中需要多个构造函数的时候，就需要用到辅助构造函数了。scala使用`this`关键字来构造辅助函数(类改名的时候就不用改构造方法名了)。
```scala
// 无参的主构造函数
class Student {
  private var name:String = null
  private var age:Int = 0

  // 辅助构造函数
  def this(name:String) {
    // 调用无参的默认主构造函数，这是必须的，否则会报错
    this()
    this.name = name
  }
  
  // 辅助构造函数同样可以指定默认值
  def this(name:String, age:Int = 18) {
    // 调用一个参数的辅助构造函数
    this(name)
    this.age = age
  }
}
```

　　对于私有的主构造函数或者辅助函数，无法在类外部调用。下面调用其实调用的是公有的辅助构造参数。
```scala
// 定义私有的主构造函数
class Student private {
    private var name:String = null
    private var age:Int = 0
    
    // 都赋上默认值
    def this(name:String = "zhangsan", age:Int = 18) {
      // 调用一个参数的辅助构造函数
      this()
      this.name = name
      this.age = age
    }

    override def toString: String = {
      s"name = ${this.name}, age = ${this.age}"
    }
  }

// 结果是 name = zhangsan, age = 18
println(new Student().toString)
```

### 构造函数的执行顺序
　　首先回顾下Java的构造函数执行顺序：创建子类对象的时候会先调用父类的构造函数，然后调用子类的构造函数。在Scala中顺序也是如此。

```scala
class Person(var name:String, var age:Int){
  // 类中的执行语句，相当于写在类的主构造函数中
  println("调用Person(父)类的主构造函数")
}

class Student(name:String, age:Int, var grade:String) extends Person(name:String, age:Int){
  // 类中的执行语句，相当于写在类的主构造函数中
  println("调用Student(子)类的柱构造函数") 
}

new Student("张三","18","大学一年级")
```

　　输出结果如下：

```console
调用Person(父)类的主构造函数
调用Student(子)类的柱构造函数
```

## 继承与多态
　　**继承** 是面向对象语言实现代码复用的重要特性，子类除了能够继承父类的属性和方法外，还可以添加自己新的属性和方法。

　　**多态** 是在继承的基础上，通过重写而实现的一种语言特性，它允许不同的子类对同一消息做出不同的反馈。
### 继承
　　Scala同Java相同，使用**extends**关键字实现类之间的继承。

```scala
class Person(var name:String, var age:Int){
  // 这是scala方法重写的语法，与Java不同。
  override def toString:String = s"name:${name},age:${age}"
}

/**
* Student中的name和age并没有var修饰，因为这两个成员变量是继承自Person类
* 而 var grade:String 是新增加的成员 
*/
class Student(name:String, age:Int, var grade:String) extends Person(name, age){
  override def toString:String = s"${super.toString},grade:${grade}"
}
```

　　子类如果需要继承父类的成员变量，在继承的时候要带上成员变量`extends Person(name, age)`，而且在声明的时候不能使用`var`和`val`关键字修饰。

### 多态
　　**多态(polymorphic)**又称**动态绑定(dynamic binding)**或者**延迟绑定(late binding)**。在代码执行期间而非编译期间确定所引用对象的实际类型(确切的子类型)，根据其实际的类型调用相应的方法。实际上就是将子类的引用赋值给父类的变量，在程序运行的时候去确定具体的子类，然后调用子类相应的方法。

　　多态遵守一个准则，对于重写的方法，不管变量声明的类型是什么，调用方法时以实际引用对象的类型(子类型)为准。什么意思呢？看下面的例子
```scala
class Person(var name:String, var age:Int){
  def squat() : Unit = {
    println("人蹲")
  }
  def sayName():Unit = {
    println(s"我是$name")
  }
}

class Zombie(name:String, age:Int) extends Person(name, age) {
  override def squat(): Unit = {
    println("小僵尸蹲")
  }
  def zombieJump():Unit = {
    println("小僵尸跳")
  }
}


// 声明一个Person类型的变量p，将子类Zombie类型的对象赋值给它
val p:Person = new Zombie("秦始皇", 5000)
p.squat()
p.sayName()
// 因为p声明为Person类型，所以对象p无法调用Zombie类特有的方法zombieJump()，除非将其强转为Zombie类。
```

　　输出结果
```console
小僵尸蹲
我是秦始皇
```
　　对于子类重写的方法，虽然声明变量p是Person类型，实际调用的是子类中的`squat()`方法。想想如果它不这么设计，就没有办法构成多态了。

## 包对象和访问权限
### 包对象
　　Scala是纯面向对象的语言，比Java还纯。通过`package`关键字声明的对象称为包对象(package object)。包对象主要用于封装常量、工具函数，可以直接通过包名直接引用。


　　包的使用规则：
* 外层包不能直接访问内层包，需要`import`。
* 内层包可以直接访问外层包
* Scala允许在任何地方使用`import`，而不像Java，只能写在`package`声明和类声明之间。

### 访问权限控制
　　回想一下Java的访问权限，从下到大有四种：private、default(默认)、protected、public，具体访问权限如下表

| 权限 | private | default | protected | public |
| :--------: | :--------: | :--------: | :--------: | :--------: |
| 类内可访问 | √ | √ | √ | √ |
| 包内可访问 | × | √ | √ | √ |
| 子类可访问 | × | × | √ | √ |
| 其他可访问 | × | × | × | √ |

　　Scala和Java不同，他只有三种权限：private、protected、默认。注意默认权限是与Java中的public对应的，而非default，并且Scala中并没有public关键字。private和protected和Java控制的作用域类似，但还有更灵活的使用方法。

　　使用`private[x]`和`protected[x]`限定到x可见，x代表包、类、单例对象。

　　`private`修饰的成员在类及其伴生对象中可见，如果想像Java一样只在类内可见，使用`private[this]`修饰对象，这种对象又叫做对象私有成员。

　　假设包结构路径为`com.zq.scala.practice`，则`private[scala] object Sample`代表限定单例对象`Sample`在`scala`包及其子包`practice`中可访问。

