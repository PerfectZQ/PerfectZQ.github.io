---
layout: post
title: Scala知识点整理
tag: Scala
---
## 目录
* TOC
{:toc}

## 数据类型
### 基本数据类型
　　Scala的基本数据类型和基本Java一致，但是首字母必须大写，因为Scala中的所有值类型都是对象：Byte、Short、Int、Long、Float、Double、Char、Boolean
```scala
val a:Int = 1;
// 可以直接使用对象的方法
println(a.toString)
// 也可以这样~
println(1.toString)
```
### String类型
　　scala中定义的String类型实际上就是java.lang.String类型，因此可以调用java中String类型的所有方法

　　除此之外，也可以调用以下方法。这些方法在java中是不存在的，实际上scala会将String类型对象阻焊换成StringOps类型对象，在遇到reverse、map、drop、slice方法调用时编译器会自动进行隐式转换
```scala
val s = "hello"
// 反转符
println(s.reverse)
// 丢弃字符 (丢弃前n个字符)
println(s.drop(3))
// 获取一定范围内的子串， 左开右闭[1,4)
println(s.slice(1, 4))
```
　　对于包含需要转义的字符的字符串，除了添加转移符`\`外，还可以使用三个双引号将字符串包裹起来。这样就可以原样输出字符串中的内容。
```scala
println("""hello world \n""")
// 原样输出：hello world \n
```
　　但是在使用`split()`或者`replace()`等函数内部使用正则表达式的方法时需要额外注意，需要添加额外的转义符。详细原因请参考我的这篇文章：[特殊字符处理异常]({% post_url 2017-07-20-split()和replace()方法特殊字符的处理 %})
### 对象比较运算
　　scala中的对象比较和java中的对象比较不同，scala是基于内容比较，而java是依据对象引用比较（即对象的物理内存地址是否一样）。基于内容比较是scala的重要特点之一
```scala
val s1 = new String("abc");
val s2 = new String("abc");
// 结果是true
println(s1 == s2) 
// 在scala中String的equals方法和==相同
println(s1.equals(s2)) 
// 如果想比较内存地址（引用）是否为是相同的，可以使用eq方法。返回false
println(s1.eq(s2))
```
### 元组类型
　　元组是Scala的一种特殊类型，它是不同类型值的聚集，将不同类型的值放在一个变量中保存。
```scala
// 一个三元组
val tuple = ("hello", "world", 1)
// 访问元组
println(tuple._1 + "," + tuple._2 + "," + tuple._3)
// 使用时还可以提取元组的内容到变量中
val (a, b, c) = tuple
// 访问元组
println(a + "," + b)
```
　　在函数中表示一个参数是二元组类型：
```scala
def tupleString2Int(tuple2: (String, String)): (Int, Int) = (tuple2._1.toInt, tuple2._2.toInt)

tupleString2Int(("1", "2"))
```
### 符号类型
　　符号类型主要起标识作用，常用于模式匹配、内容判断中。符号类型(Symbol) 定义时需要`'`(单引号)符号
```scala
// 定义一个符号类型的变量s，变量s会被默认识别为Symbol类型
val s = 'start
// 显示声明符号类型
val s_ : Symbol = 'start
// 符号类型主要起标识作用，常用与模式匹配、内容判断中
// for example
if (s == s_) println(true) // 使用 == 来比较变量时，比较的是变量的内容而非引用
else println(false)
// 直接输出符号类型的变量会按原样输出
println("s = " + s)
```

## 函数
　　一个scala函数：
```scala
def gcd(x:Int, y:Int):Int = {
  if(x % y == 0)
    y // 函数的返回值
  else
    gcd(y, x % y) // 函数的返回值
}
```
　　其中`def`是函数声明，`gcd`是函数名称，`x:Int`和`y:Int`是Int类型的函数形参，最后的`:Int`是函数返回值类型。`=`后的花括号包含的是函数体，**当函数体只有一行的时候可以省略掉{}**。函数中的最后一条执行语句为函数的返回值，返回值可以加`return`关键字，也可以不加。

　　scala的函数还有类型推导功能，如果不写函数返回值类型，会根据最终的返回值推导出函数的返回值类型。
```scala
def sum(x:Int, y:Int) = x + y
```
　　类型推导类型有两个限制：
1. 如果函数中存在递归调用，则必须显示的指定函数的返回值类型，不能省略，否则编译报错。
![有帮助的截图]({{ site.url }}/assets/scala_fuction_error1.PNG)
2. 如果使用`return`指定返回值，则必须显示指定函数的返回值类型，不能省略，否则编译报错。
![有帮助的截图]({{ site.url }}/assets/scala_fuction_error2.PNG)
### 值函数（函数字面量）
　　scala中函数也是对象，可以赋值给变量，这种函数称为值函数或函数字面量。
```scala
val sum = (x:Int, y:Int) => { x + y }
```
　　其中`sum`是变量名(函数名)，`(x:Int, y:Int)`是函数参数，`=>`是函数映射符，`{}`中的内容是函数体，同理如果只有一行可以省略。

　　像`(x:Int, y:Int) => { x + y }`这样的表达式被称为Lambda表达式，因此值函数也被称为Lambda函数或者匿名函数。

　　值函数不能想正常函数一样指定返回值类型，只能用类型推导的方式确定返回值类型，因此也不可以包含关键字`return`.

　　调用函数和使用普通函数一样`sum(1, 2)`。

　　值函数可以跟一般的val变量一样使用`lazy`关键字修饰，只有当程序真正使用到该函数字面量的时候才会被创建。

　　值函数最常用的场景是作为高阶函数的输入参数，例如我们常用的`map()`
```scala
def map[B](f: (A) => B):Array[B]
```
　　其中 `f` 就是值函数，输入参数只有一个，类型为`A`，返回值类型是`B`，其中`B`是泛型。

　　例如将数组中的各个元素都加1
```scala
// 定义一个值函数，作用于数组中的每一个元素
val arr = Array(1, 2, 3, 4)
val increment1 = (x:Int) => { x + 1 }
val resultArr = arr.map(increment1)
```
　　而在实际使用中值函数一般都只使用一次，直接用匿名函数作为参数。
```scala
val arr = Array(1, 2, 3, 4)
val resultArr = arr.map((x:Int) => { x + 1 })
```
　　scala语法博大精深，在实际使用中也不用这么麻烦，写这么多代码，可以将其简化，下面就逐步讲解神(cao)奇(dan)的语法糖：
```scala
// 因为arr是Int类型的数组，使用map的时候可以通过类型推断得知它的输入类型是Int，因此可以将输入参数的类型省略
arr.map((x) => { x + 1 })

// 当值函数的输入参数只有一个的时候，可以将()省略，map函数的输入参数一定是一个。
arr.map(x => { x + 1 })

// => 右面只有一句表达式，所以{}也可以省略了
arr.map(x => x + 1)

// 对于值函数， => 左面的输入参数 x 在 => 右面只出现过一次，因此可以用占位符 _ 代替
arr.map(_ + 1)
```
　　需要注意的是：`arr.map(_+1)`合法是因为arr是Int类型的可以推断出`_`的类型。但是单独声明值函数就会出错，例如：
```scala
// val increment = (x:Int) => {1 + x} 的简写
val increment = 1 + _
```
　　即便有`1 +`这种表达式，但是还不足让编译器推断出准确的类型，因为`_`还有可能是String类型，这时就需要指定明确的类型。
```scala
val increment = 1 + (_:Int)
```
　　或者指定`increment`的类型，这样也可以。
```scala
val increment:Int = 1 + _
```
### 偏函数
