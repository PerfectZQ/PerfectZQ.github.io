---
layout: post
title: Scala知识点整理
tag: Scala
---
## 目录
* TOC
{:toc}

## 变量
　　scala中包含两种类型的变量：可变变量和不可变变量。分别用`var`和`val`定义。

　　可变变量就和java中的对象变量一样，变量被赋值之后仍然随着程序的运行而改变。
```scala
var str = "abc"
str = "def"
```
　　而不可变变量就相当于java中被final修饰的变量，一旦被赋值就不可以再修改。
```scala
val str = "abc"
// 不能再修改它的值！会报错
str = "def"
```
　　编译报错：
```console
Error:(43, 7) reassignment to val
  sum = "edf"
```
　　**需要特别注意的是：scala中的变量在定义的时候必须初始化赋值。无论是可变还是不可变变量**

　　可变变量在初始化时可以使用占位符`_`，会给不同类型的对象赋上默认的初始值
```scala
var str:String = _
str:String = null

var in:Int = _
in:Int = 0

var flo:Float = _
flo:Float = 0.0

var c:Char = _
c:Char = ?
```
### lazy 变量
　　scala中的**不可变变量**可以用`lazy`关键字修饰，这样变量只有在真正被使用的时候才会赋值。
```scala
// 普通变量，定义时就已经赋值
val test1 = "test1"
test1: String = test1

// lazy修饰，定义时没有被赋值
lazy val test2 = "test2"
test2: String = <lazy>

// 使用时会被赋值
test2
res0: String = test2
```
　　**需要注意的是：`lazy`只能修饰`val`类型的变量，不能用于`var`，主要是为了避免程序运行中变量还未使用便被重新赋值。**
　　


## 数据类型
### 基本数据类型
　　Scala的基本数据类型和基本Java一致，但是首字母必须大写，因为Scala中的所有值类型都是对象：Byte、Short、Int、Long、Float、Double、Char、Boolean
```scala
val a:Int = 1;
// 可以直接使用对象的方法
println(a.toString)
// 也可以这样~
println(1.toString)
```
### String类型
　　scala中定义的String类型实际上就是java.lang.String类型，因此可以调用java中String类型的所有方法

　　除此之外，也可以调用以下方法。这些方法在java中是不存在的，实际上scala会将String类型对象阻焊换成StringOps类型对象，在遇到reverse、map、drop、slice方法调用时编译器会自动进行隐式转换
```scala
val s = "hello"
// 反转符
println(s.reverse)
// 丢弃字符 (丢弃前n个字符)
println(s.drop(3))
// 获取一定范围内的子串， 左开右闭[1,4)
println(s.slice(1, 4))
```
　　对于包含需要转义的字符的字符串，除了添加转移符`\`外，还可以使用三个双引号将字符串包裹起来。这样就可以原样输出字符串中的内容。
```scala
println("""hello world \n""")
// 原样输出：hello world \n
```
　　但是在使用`split()`或者`replace()`等函数内部使用正则表达式的方法时需要额外注意，需要添加额外的转义符。详细原因请参考我的这篇文章：[特殊字符处理异常]({% post_url 2017-07-20-split()和replace()方法特殊字符的处理 %})
### 对象比较运算
　　scala中的对象比较和java中的对象比较不同，scala是基于内容比较，而java是依据对象引用比较（即对象的物理内存地址是否一样）。基于内容比较是scala的重要特点之一
```scala
val s1 = new String("abc");
val s2 = new String("abc");
// 结果是true
println(s1 == s2) 
// 在scala中String的equals方法和==相同
println(s1.equals(s2)) 
// 如果想比较内存地址（引用）是否为是相同的，可以使用eq方法。返回false
println(s1.eq(s2))
```
### 元组类型
　　元组是Scala的一种特殊类型，它是不同类型值的聚集，将不同类型的值放在一个变量中保存。
```scala
// 一个三元组
val tuple = ("hello", "world", 1)
// 访问元组
println(tuple._1 + "," + tuple._2 + "," + tuple._3)
// 使用时还可以提取元组的内容到变量中
val (a, b, c) = tuple
// 访问元组
println(a + "," + b)
```
　　在函数中表示一个参数是二元组类型：
```scala
def tupleString2Int(tuple2: (String, String)): (Int, Int) = (tuple2._1.toInt, tuple2._2.toInt)

tupleString2Int(("1", "2"))
```
### 符号类型
　　符号类型主要起标识作用，常用于模式匹配、内容判断中。符号类型(Symbol) 定义时需要`'`(单引号)符号
```scala
// 定义一个符号类型的变量s，变量s会被默认识别为Symbol类型
val s = 'start
// 显示声明符号类型
val s_ : Symbol = 'start
// 符号类型主要起标识作用，常用与模式匹配、内容判断中
// for example
if (s == s_) println(true) // 使用 == 来比较变量时，比较的是变量的内容而非引用
else println(false)
// 直接输出符号类型的变量会按原样输出
println("s = " + s)
```
## 集合
　　scala中的集合分两种：可变和不可变。可变集合可以被更新或修改，增删改操作会作用与原集合对象。而不可变集合是不可以被更新或修改的，增删改会导致生成新的集合对象，原集合对象没有任何变化。

　　在不导入任何包的情况下，scala会默认自动导入下面的包：
```scala
import java.lang._
import scala._
import Predf._
```
　　而Predef对象中包含了Set、Map等定义
```scala
type Map[A, +B] = immutable.Map[A, B]
type Set[A]     = immutable.Set[A]
val Map         = immutable.Map
val Set         = immutable.Set
```
　　因此scala默认导入的包是不可变集合，`scala.collection.immutable`，想要使用可变集合就要手动导入`scala.collection.mutable`包中的可变集合。

　　mutable和immutable包中常用的可变集合和不可变集合的对应关系表如下：

| 可变(mutable) | 不可变(immutable) |
| :-------- | :-------- |
| ArrayBuffer、ArraySeq | Array |
| ListBuffer、MutableList | List |
| LinkedList、DoubleLinkedList | / |
| Queue | / |
| Stack | Stack |
| HashMap | HashMap |
| HashSet | HashSet |
| ArrayStack |  |

### 数组(Array)

### 列表(List)

### 集合(Set)

### 映射(Map)

### 队列(Queue)

### 栈(Stack)

## 函数
　　一个scala函数：
```scala
def gcd(x:Int, y:Int):Int = {
  if(x % y == 0)
    y // 函数的返回值
  else
    gcd(y, x % y) // 函数的返回值
}
```
　　其中`def`是函数声明，`gcd`是函数名称，`x:Int`和`y:Int`是Int类型的函数形参，最后的`:Int`是函数返回值类型。`=`后的花括号包含的是函数体，**当函数体只有一行的时候可以省略掉{}**。函数中的最后一条执行语句为函数的返回值，返回值可以加`return`关键字，也可以不加。

　　scala的函数还有类型推导功能，如果不写函数返回值类型，会根据最终的返回值推导出函数的返回值类型。
```scala
def sum(x:Int, y:Int) = x + y
```
　　类型推导有两个限制：
1. 如果函数中存在递归调用，则必须显示的指定函数的返回值类型，不能省略，否则编译报错。
![有帮助的截图]({{ site.url }}/assets/scala_fuction_error1.PNG)
2. 如果使用`return`指定返回值，则必须显示指定函数的返回值类型，不能省略，否则编译报错。
![有帮助的截图]({{ site.url }}/assets/scala_fuction_error2.PNG)

### 值函数（函数字面量）
　　scala中函数也是对象，可以赋值给变量，这种函数称为值函数或函数字面量。
```scala
val sum = (x:Int, y:Int) => { x + y }
```
　　其中`sum`是变量名(函数名)，`(x:Int, y:Int)`是函数参数，`=>`是函数映射符，`{}`中的内容是函数体，同理如果只有一行可以省略。

　　像`(x:Int, y:Int) => { x + y }`这样的表达式被称为Lambda表达式，因此值函数也被称为Lambda函数或者匿名函数。

　　值函数不能像正常函数一样指定返回值类型，只能用类型推导的方式确定返回值类型，因此函数体中也不可以包含关键字`return`.
```scala
//  值函数不能在参数后面指定返回值类型
val sum = (x:Int,y:Int):Int=>x+y
```
　　编译报错：
```console
Error:(42, 37) not found: type +
  val sum = (x:Int, y:Int):Int => x + y
Error:(42, 14) not found: value x
  val sum = (x:Int, y:Int):Int => x + y
Error:(42, 21) not found: value y
  val sum = (x:Int, y:Int):Int => x + y
```

　　调用函数和使用普通函数一样，例如：`sum(1, 2)`。

　　值函数可以跟一般的val变量一样使用`lazy`关键字修饰，只有当程序真正使用到该函数字面量的时候才会被创建。

　　值函数最常用的场景是作为高阶函数的输入参数，例如我们常用的`map()`
```scala
def map[B](f: (A) => B):Array[B]
```
　　其中 `f` 就是值函数，输入参数只有一个，类型为`A`，返回值类型是`B`，其中`B`是泛型。

　　例如将数组中的各个元素都加1
```scala
// 定义一个值函数，作用于数组中的每一个元素
val arr = Array(1, 2, 3, 4)
val increment1 = (x:Int) => { x + 1 }
val resultArr = arr.map(increment1)
```
　　而在实际使用中值函数一般都只使用一次，直接用匿名函数作为参数。
```scala
val arr = Array(1, 2, 3, 4)
val resultArr = arr.map((x:Int) => { x + 1 })
```
　　scala语法博大精深，在实际使用中也不用这么麻烦，写这么多代码，可以将其简化，下面就逐步讲解神(cao)奇(dan)的语法糖：
```scala
// 因为arr是Int类型的数组，使用map的时候可以通过类型推断得知它的输入类型是Int，因此可以将输入参数的类型省略
arr.map((x) => { x + 1 })

// 在调用函数时，如果只有一个参数，可以用花括号`{}`来替代小括号`()`。map函数只有一个参数。
arr.map {
  (x) => { x + 1 }
}

// 在定义函数时，如果函数的输入参数只有一个，可以将()省略，map函数的参数是函数类型，这个函数的输入参数是一个。
arr.map {
  x => { x + 1 }
}

// => 右面只有一句表达式，所以{}也可以省略了
arr.map {
  x => x + 1
}

// 对于值函数， => 左面的输入参数 x 在 => 右面只出现过一次，因此可以用占位符 _ 代替
arr.map {
  _ + 1
}


```
　　需要注意的是：`arr.map(_+1)`合法是因为arr是Int类型的可以推断出`_`的类型。但是单独声明值函数就会出错，例如：
```scala
// val increment = (x:Int) => {1 + x} 的简写
val increment = 1 + _
```
　　即便有`1 +`这种表达式，但是还不足让编译器推断出准确的类型，因为`_`还有可能是String类型，这时就需要指定明确的类型。
```scala
val increment = 1 + (_:Int)
```
　　或者指定`increment`的具体类型，输入参数是Int类型，返回值是Int类型。这样也可以。
```scala
val increment:(Int) => Int = 1 + _
```
### 高阶函数
　　**一个函数的输入参数中有函数类型的参数**，或者**返回值的类型是函数类型**，那么这个函数就是**高阶函数**。

　　输入参数是函数类型的
```scala
def higherOrderFunction(f: (Double) => Double) = {
    f(1)
}
```

　　返回值是函数类型的
```scala
def higherOrderFunction(factor: Int): (Double) => Double = {
    (x: Double) => factor * x
  }
```

　　常见高阶函数的使用：其中A是调用函数的迭代对象的元素的类型，例如:`Array(1,2).map()`，调用函数的迭代对象是`Array[Int]`，所以`A`是`Int`类型。 

1. map() 将函数`f`应用于调用`map()`的可迭代对象的每一个元素，返回新的可迭代对象。

```scala
// Array的map函数定义
def map[B](f: (A) => B): Array[B]

// Array类型的map函数
Array("kafka","sparkstreaming","elasticsearch").map(_*2)

// List类型的map函数
List("kafka", "sparkstreaming", "elasticsearch").map((_, 1))

// Map类型的map函数
Map("kafka" -> 1, "sparkstreaming" -> 2, "elasticsearch" -> 3).map(_._1)
```
2. flatMap() 将函数`f`应用于调用`flatMap()`的可迭代对象的每一个元素，每一个元素会转换成相应的集合`GenTraverableOnce[B]`，最后将得到的所有集合扁平化，返回一个新的可迭代对象。

```scala
// Array的flatMap函数定义
def flatMap[B](f: (A) => GenTraversableOnce[B]): Array[B]

// flatMap的使用
Array("Hello world", "This is John Snow").flatMap(
    sentence => {
      val words: Array[String] = sentence.split("")
      val statistics: Array[(String, Int)] = words.map(word => {
        (word, 1)
      })
      statistics
    })

// 简写
Array("Hello world", "This is John Snow").flatMap { _.split(" ").map((_, 1)) }
```
3. filter() 返回所有满足条件`p`的元素

```scala
// Array的filter函数定义
def filter(p: (T) => Boolean): Array[T]

// filter的使用，返回大于3的元素
Array(1, 5, 7, 3, 4).filter(_ > 3)
```
4. reduce() 使用`op`作用于集合之上，返回结果类型为`A1`。`op`是特定的联合二元算子(associative binary operator)，`A1`为`A`的超类。

```scala
// Array的reduce函数定义
def reduce[A1 >: A](op: (A1, A1) => A1): A1

// reduce的使用，结果是10
Array(1, 2, 3, 4).reduce((x1, x2) => {
    println(s"x1 = ${x1}, x2 = ${x2}")
    x1 + x2
  })
// 输出结果
// x1 = 1, x2 = 2
// x1 = 3, x2 = 3
// x1 = 6, x2 = 4


// 简写
Array(1, 2, 3, 4).reduce(_ + _)

/**
* reduce还有两个变种，reduceLeft()、reduceRight()。
* reduceLeft()和reduce()一样，op函数按照集合中元素的顺序从左到右进行reduce操作，
* 而reduceRight()作用顺序相反。
* 只要记住left就是取元素的顺序和x1、x2的赋值顺序都是从左往右，
* 计算结果也是先从左开始赋值(x1)，right就全部反过来就可以了。
*/
Array(1, 2, 3, 4).reduceRight((x1, x2) => {
    println(s"x1 = ${x1}, x2 = ${x2}")
    x1 + x2
  })
// 输出结果
// x1 = 3, x2 = 4
// x1 = 2, x2 = 7
// x1 = 1, x2 = 9
```
5. fold() 使用联合二元算子对集合进行fold操作，`z`为给定的初始值。和reduce差不多，区别就是有初始值`z`

```scala
// Array的fold函数定义
def fold[A1 >: A](z: A1)(op: (A1, A1) => A1): A1

// fold的使用，结果是10
Array(1, 2, 3, 4).fold(0)((x1, x2) => {
    println(s"x1 = ${x1}, x2 = ${x2}")
    x1 + x2
  })
// 输出结果
// x1 = 0, x2 = 1
// x1 = 1, x2 = 2
// x1 = 3, x2 = 3
// x1 = 6, x2 = 4

// 简写
Array(1, 2, 3, 4).fold(0)(_ + _)

/**
* fold同样也有两个变种，foldLeft()、foldRight()。
* foldLeft()和fold()一样，op函数按照集合中元素的顺序从左到右进行fold操作，
* 而foldRight()作用顺序相反
*/
Array(1, 2, 3, 4).foldRight(0)((x1, x2) => {
    println(s"x1 = ${x1}, x2 = ${x2}")
    x1 + x2
  })
// 输出结果
// x1 = 4, x2 = 0
// x1 = 3, x2 = 4
// x1 = 2, x2 = 7
// x1 = 1, x2 = 9
```
### 闭包
　　"An Object is data with functions.A Closure is a function with data" —— Jon D. Cook

　　闭包是由函数和运行时的数据决定的，也可以理解为函数和上下文。
```scala
// 自由变量(上下文)，在运行中随时可能发生变化
var factor = 2
// 函数
val f = (x:Int) => x * factor

f(2) // 得到结果 4

factor = 3

f(2) // 得到结果6
```

　　自由变量factor在程序运行时随时可能发生变化，它处于一个开放的状态。但是执行函数`f`时，就临时确定了自由变量`factor`的值，自由变量就暂时处于一个封闭的状态，这种存在从开放到封闭过程的函数就称为闭包。

　　高阶函数也可以理解为闭包，例如：
```scala
def higherOrderdFunction(f:Double => Double) = {
  println(f(1.7))
}

// 向上取整
val f1 = (x:Double) => Math.ceil(x)
// 向下取整
val f2 = (x:Double) => Math.floor(x)

higherOrderdFunction(f1) // 结果是2.0
higherOrderdFunction(f2) // 结果是1.0
```
　　可见 `f` 就是自由变量(上下文)，函数在运行时传入的参数不一样得到的结果也是不一样的，因此高阶函数也是一种闭包(closure)。
### 函数柯里化
　　一个返回值类型是函数类型的高阶函数：
```scala
def higherOrderFunction(factor: Int): (Double) => Double = {
    (x: Double) => factor * x
  }
```

　　用下面的方式调用这个函数：
```scala
higherOrderFunction(3)(5.0) // 结果是 15.0

// 实际调用过程是下面的样子。
val f = higherOrderFunction(3) // f = (x: Double) => 3 * x
f(5.0) // 结果 15.0 
```

　　这种调用方式合并的函数调用方式与柯里化函数十分相似，柯里化函数的定义是这个样子的。
```scala
def curryMultiply(factor: Int)(x: Double) = factor * x
// 调用
curryMultiply(3)(5.0) // 结果是15.0
```
　　需要注意的是:**柯里化函数和高阶函数不同，curryMultiply(3)并不能返回一个函数对象，需要写上所有的柯里化参数。**

　　如果想让柯里化的函数生成新的函数，就需要下一节的**部分应用函数(partially applied function)**

### 部分应用函数
　　让柯里化函数生成部分应用函数。
```scala
val part = curryMultiply(3)_
part(5.0) // 结果是15.0

// 注意函数名和 _ 之间有空格
val part2 = curryMultiply _
part2(3)(5.0)
```
　　其中`part`是`(Double) => Double`类型的函数，`part2`是`(Int) => (Double => Double)`类型的函数。`part2`就可以像高阶函数一样来返回函数对象了。

　　不只是柯里化函数可以转为部分应用函数，普通的函数也可以。
```scala
def price(x1: Double, x2: Double, x3: Double): Double = {
  x1 + x2 * x3
}

// 一个参数的部分应用函数，返回一个 Double => Double 类型的函数
def price_1 = price(_:Double, 699.0, 0.7)
// 调用
price_1(18.0)

// 两个参数的部分应用函数，返回一个 (Double, Double) => Double 类型的函数
def price_2 = price(_:Double, _:Double, 0.7)
// 调用
price_2(18.0, 699.0)

// 两个参数的部分应用函数，返回一个 (Double, Double, Double) => Double 类型的函数
def price_3 = price(_:Double, _:Double, _:Double)
// 调用
price_3(18.0, 699.0, 0.7)

// 等价与 price_3
def price_4 = price _
```
### 偏函数
　　离散数学中，函数的概念主要是限制了关系概念中的一对多，但是允许多对一。即在函数`y = f(x)`中 `x0、x1、x2`可以对应同一个`y`值，但是一个`x`值只能对应一个`y`值，不可以对应多个`y`值。 如果所有的`x`值，在`y = f(x)`函数中都能找到对应的`y`值，那么这个函数就是 **全函数**，如果存在某个`x`找不到对应的`y`值，那么这个函数就是 **偏函数**。

　　scala中的偏函数定义为`trait PartialFunction[-A, +B] extends (A => B)`。其中泛型`A`是片函数的输入参数类型，泛型`B`是偏函数的返回结果类型。偏函数只处理参数定义域的子集，对于子集外的参数会抛出异常，这一特点与scala模式匹配的特点吻合。

```scala
// 定义一个偏函数，只处理偶数值的参数
val isEven:PartialFunction[Int, String] = {
    case x if x % 2 == 0 => x + "is even"
  }

// 对于定义域子集外的参数会抛出异常
isEven(11)
/*
Caused by: scala.MatchError: 11 (of class java.lang.Integer)
	at scala.PartialFunction$$anon$1.apply(PartialFunction.scala:253)
	at scala.PartialFunction$$anon$1.apply(PartialFunction.scala:251)
	at com.zq.scala.函数.部分应用函数$$anonfun$2.applyOrElse(部分应用函数.scala:41)
	at com.zq.scala.函数.部分应用函数$$anonfun$2.applyOrElse(部分应用函数.scala:41)
	at scala.runtime.AbstractPartialFunction.apply(AbstractPartialFunction.scala:36)
	at com.zq.scala.函数.部分应用函数$.<init>(部分应用函数.scala:45)
	at com.zq.scala.函数.部分应用函数$.<clinit>(部分应用函数.scala)
	... 1 more
*/

// 除了定义一个变量是PartialFunction[Int, String]类型的，还可以直接定义函数
def partial: PartialFunction[Any, Unit] = {
    case x: Int => println("Int")
    case x: String = > println ("String")
  }
```
