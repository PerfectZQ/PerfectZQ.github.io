---
layout: post
title: 爬虫-Web基础
tag: Spider
---

## HTTP/1.1 协议 header
　　通常HTTP包含**Request请求消息**和**Response响应消息**两种消息。这两种消息都是由一个起始行、一个或多个头域、一个代表头域结束的空行和可选的消息体组成。例如一个Request请求消息：
```console
# 下面是起始行
GET /UpdateCheck.aspx?isBeta=False HTTP/1.1
# 下面是多个头域
 Accept: text/html,application/xhtml+xml,application/xml;q=0.9,image/webp,image/apng,*/*;q=0.8
 Accept-Encoding: gzip, deflate
 Accept-Language: zh-CN,zh;q=0.8
 User-Agent: Mozilla/5.0 (Windows NT 10.0; Win64; x64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/61.0.3163.100 Safari/537.36
# 下面是代表头域结束的空行

```

　　头域分为 **通用头域**、**请求头域**、**响应头域** 和 **实体头域** 四种。每个头域由一个域的名称、冒号和域值三部分组成，\[例如： Referer(域名):(冒号)http://download.google.com/(域值)]。域名是大小写无关的，域值前可以添加任何数量的空格符，头域可以被扩展为多行，在每行开始处，使用至少一个空格和制表符。

　　**通用头域** 是客户端和服务器都可以使用的头部，可以在客户端、服务器和其他应用程序之间提供一些非常有用的通用功能，如Date头部。

　　**请求头域** 是请求报文特有的，它们为服务器提供了一些额外信息，比如客户端希望接收什么类型的数据，如Accept头部。

　　**响应头域** 便于为客户端提供信息，比如，客服端在与哪种类型的服务器进行交互，如Server头部。

　　**实体头域** 指的是用于应对实体主体部分的头部，比如，可以用实体头部来说明实体主体部分的数据类型，如Content-Type头部。

### 通用头域
　　**通用头域**：Request请求消息和Response响应消息都支持的头域。通用头域包含Cache-Control、Connection、Date、Pragma、Transfer-Encoding、Upgrade、Via。对通用头域的扩展要求通讯双方都支持此扩展，如果存在不支持的通用头域，一般将会作为实体头域处理。

* **Cache-Control：** 指定请求和响应遵循的缓存机制。在请求消息或响应消息中设置Cache-Control并不会修改另一个消息处理过程中的缓存处理过程。请求时的缓存指令包括no-cache、no-store、max-age、max-stale、min-fresh、only-if-cached，响应消息中的指令包括public、private、no-cache、no-store、no-transform、must-revalidate、proxy-revalidate、max-age。例如：Cache-Control: no-cache  

| 值 | 含义 |  
| :-------- | :-------- |
| no-cache | 指示请求或响应消息不能缓存，实际上是可以存储在本地缓存区中的，只是在与原始服务器进行新鲜度验证之前，缓存不能将其提供给客户端使用。 |
| no-store | 缓存应该尽快从存储器中删除文档的所有痕迹，因为其中可能会包含敏感信息。 |
| max-age | 缓存无法返回缓存时间长于max-age规定秒的文档，若不超规定秒浏览器将不会发送对应的请求到服务器，数据由缓存直接返回；超过这一时间段才进一步由服务器决定是返回新数据还是仍由缓存提供。若同时还发送了max-stale指令，则使用期可能会超过其过期时间。 |
| min-fresh | 至少在未来规定秒内文档要保持新鲜，接受其新鲜生命期大于其当前 Age 跟 min-fresh 值之和的缓存对象。 |
| max-stale | 指示客户端可以接收过期响应消息，如果指定max-stale消息的值，那么客户端可以接收过期但在指定值之内的响应消息。 |
| only-if-cached | 只有当缓存中有副本存在时，客户端才会获得一份副本。 |
| Public | 指示响应可被任何缓存区缓存，可以用缓存内容回应任何用户。 |
| Private | 指示对于单个用户的整个或部分响应消息，不能被共享缓存处理，只能用缓存内容回应先前请求该内容的那个用户。 |

* **Connection：** 表示是否需要持久连接。如果web服务器端看到这里的值为"Keep-Alive"，或者看到请求使用的是HTTP 1.1（HTTP 1.1默认进行持久连接），它就可以利用持久连接的优点，当页面包含多个元素时（例如Applet，图片），显著地减少下载所需要的时间。要实现这一点， web服务器需要在返回给客户端HTTP头信息中发送一个Content-Length（返回信息正文的长度）头，最简单的实现方法是：先把内容写入ByteArrayOutputStream，然后在正式写出内容之前计算它的大小。例如：Connection: keep-alive  

| 值 | 含义 |  
| :-------- | :-------- |
| Close | 告诉WEB服务器或者代理服务器，在完成本次请求的响应后，断开连接，不要等待本次连接的后续请求了。 |
| Keepalive | 告诉WEB服务器或者代理服务器，在完成本次请求的响应后，保持连接，等待本次连接的后续请求。 |
| Keep-Alive | 如果浏览器请求保持连接，则该头部表明希望 WEB 服务器保持连接多长时间（秒），如Keep-Alive：300。 |

* **Date：** Date头域表示消息发送的时间，服务器响应中要包含这个头部，因为缓存在评估响应的新鲜度时要用到，其时间的描述格式由RFC822定义。例如，Date:Mon, 31 Dec 2001 04:25:57 GMT。Date描述的时间表示世界标准时，换算成本地时间，需要知道用户所在的时区。例如，Date:Mon,31Dec200104:25:57GMT。Date描述的时间表示世界标准时，换算成本地时间，需要知道用户所在的时区。例如：Date: Tue, 15 Nov 2010 08:12:31 GMT  

* **Pragma：** 包含实现特定的指令，最常用的是Pragma:no-cache。在HTTP/1.1协议中，它的含义和Cache-Control:no-cache相同。例如：Pragma: no-cache  

* **Transfer-Encoding：** WEB 服务器表明自己对本响应消息体（不是消息体里面的对象）作了怎样的编码，比如是否分块（chunked）。例如：Transfer-Encoding:chunked  

* **Upgrade：** 它可以指定另一种可能完全不同的协议，如HTTP/1.1客户端可以向服务器发送一条HTTP/1.0请求，其中包含值为"HTTP/1.1"的Update头部，这样客户端就可以测试一下服务器是否也使用HTTP/1.1了。例如：Upgrade: HTTP/2.0, SHTTP/1.3, IRC/6.9, RTA/x11

* **Via：** 列出从客户端到 OCS 或者相反方向的响应经过了哪些代理服务器，他们用什么协议（和版本）发送的请求。当客户端请求到达第一个代理服务器时，该服务器会在自己发出的请求里面添加 Via 头部，并填上自己的相关信息，当下一个代理服务器 收到第一个代理服务器的请求时，会在自己发出的请求里面复制前一个代理服务器的请求的Via头部，并把自己的相关信息加到后面，以此类推，当 OCS 收到最后一个代理服务器的请求时，检查 Via 头部，就知道该请求所经过的路由。例如：Via：1.0 236-81.D07071953.sina.com.cn:80 (squid/2.6.STABLE13)。例如：Via: 1.0 fred, 1.1 nowhere.com (Apache/1.1)  

### 实体头域
　　**实体头域**：实体头部提供了有关实体及其内容的大量信息，从有关对象类型的信息，到能够对资源使用的各种有效的请求方法。总之，实体头部可以告知接收者它在对什么进行处理。请求消息和响应消息都可以包含实体信息，实体信息一般由实体头域和实体组成。实体头域包含关于实体的原信息，实体头包括信息性头部Allow、Location，内容头部Content-Base、Content-Encoding、Content-Language、Content-Length、Content-Location、Content-MD5、Content-Range、Content-Type，缓存头部Etag、Expires、Last-Modified、extension-header。

* **Allow：** 服务器支持哪些请求方法（如GET、POST等）。例如：Allow: GET, POST

* **Location** 表示客户应当到哪里去提取文档，用于将接收端定位到资源的位置（URL）上。Location通常不是直接设置的，而是通过HttpServletResponse的sendRedirect方法，该方法同时设置状态代码为302。

* **Content-Base：** 解析主体中的相对URL时使用的基础URL。
  
* **Content-Encoding：** 表示请求或响应内容的编码（Encode）方法。只有在解码之后才可以得到Content-Type头指定的内容类型。利用gzip压缩文档能够显著地减少HTML文档的 下载时间。Java的GZIPOutputStream可以很方便地进行gzip压缩，但只有Unix上的Netscape和Windows上的IE 4、IE 5才支持它。因此，Servlet应该通过查看Accept-Encoding头（即request.getHeader("Accept- Encoding")）检查浏览器是否支持gzip，为支持gzip的浏览器返回经gzip压缩的HTML页面，为其他浏览器返回普通页面。     

* **Content-Language：** 表示请求或响应内容的语言类型，例如：zh-cn

* **Content-Length：** 表示请求或响应内容长度。只有当浏览器使用持久HTTP连接时才需要这个数据。如果你想要利用持久连接的优势，可以把输出文档写入 ByteArrayOutputStram，完成后查看其大小，然后把该值放入Content-Length头，最后通过byteArrayStream.writeTo(response.getOutputStream()发送内容。     

* **Content-Location：** 表示请求或响应内容实际所处的位置。

* **Content-MD5：** 表示请求或响应内容MD5校验和。

* **Content-Range：** 随部分实体一同发送；标明被插入字节的低位与高位字节偏移，也标明此实体的总长度。     

* **Content-Type：** 表示请求或响应内容属于什么MIME类型，一般只有post提交时才需要设置该属性。     

* **Etag：** 就是一个对象（比如URL）的标志值，就一个对象而言，比如一个html文件，如果被修改了，其Etag也会别修改，所以，ETag的作用跟Last-Modified的作用差不多，主要供WEB服务器判断一个对象是否改变了。比如前一次请求某个html文件时，获得了其 ETag，当这次又请求这个文件时，浏览器就会把先前获得ETag值发送给WEB服务器，然后WEB服务器会把这个ETag跟该文件的当前ETag进行对比，然后就知道这个文件有没有改变了。

* **Expires：** 响应过期的日期和时间。为0证明不缓存。例如：Expires: Thu, 01 Dec 2010 16:00:00 GMT

* **Last-Modified：** WEB服务器认为对象的最后修改时间，比如文件的最后修改时间，动态页面的最后产生时间等等。例如：Last-Modified：Tue, 06 May 2008 02:42:43 GMT.  
　　
**请求头域**和**响应头域**在下面介绍。

### Request请求消息：
```console
# Request请求消息的格式如下
MethodSPRequest-URISPHTTP-VersionCRLF
```

　　其中SP代表空格，CRLF代表回车。实际是下面的样子：
```consle
Method Request-URI HTTP-Version
...
...

```    
* **Method** 表示对Request-URI所使用的方法，这个字段是大小写铭敏感的，包括OPTIONS、GET、HEAD、POST、PUT、DELETE、TRACE。其中GET和HEAD方法都是请求返回Request-URI所标识的信息，区别就是HEAD在响应时可以不返回消息体。POST可以在请求服务器的同时附加上实体信息，例如表单信息。
　　
* **Request-URI** 遵循URI格式，如果此字段是星号(*)，说明请求并用于某个特定的资源地址，而是用于服务器本身

* **HTTP-Version** 表示支持的HTTP版本。例如HTTP/1.1。

　　除此之外，请求头还允许客户端向服务器传递关于客户端和请求的附加信息。请求头域可能包含Accept、Accept-Charset、Accept-Encoding、Accept-Language、Authorization、From、Host、If-Modified-Since、If-Match、If-None-Match、If-Range、If-Range、If-Unmodified-Since、Max-Forwards、 Proxy-Authorization、Range、Referer、User-Agent。对于这些扩展要求通讯双方都支持、如果存在不支持的请求域，一般会将其当成实体头域来处理。

　　典型的请求消息：
```consle
GET http://download.google.com/somedata.exe 
 Host: download.google.com
 Accept:*/* 
 Pragma: no-cache 
 Cache-Control: no-cache 
 Referer: http://download.google.com/ 
 User-Agent:Mozilla/4.04[en](Win95;I;Nav) 
 Range:bytes=554554- 

```

　　请求头域介绍：
  
* **Accept：** 指定客户端能够接收的内容类型，内容类型中的先后次序表示客户端接收的先后次序。例如：	Accept: text/plain, text/html  

* **Accept-Charset：** 浏览器可以接受的字符编码集。例如：Accept-Charset: gb2312,utf-8;q=0.7,*;q=0.7

* **Accept-Encoding：** 指定客户端浏览器可以支持的web服务器返回内容压缩编码类型。表示允许服务器在将输出内容发送到客户端以前进行压缩，以节约带宽。而这里设置的就是客户端浏览器所能够支持的返回压缩格式。例如：Accept-Encoding: gzip,deflate  

* **Accept-Language：** 指定HTTP客户端浏览器用来展示返回信息所优先选择的语言。例如：Accept-Language: zh-cn,zh;q=0.5  

* **Authorization：** HTTP授权的授权证书。例如：Authorization: Basic QWxhZGRpbjpvcGVuIHNlc2FtZQ==

* **Cookie：** HTTP请求发送时，会把保存在该请求域名下的所有cookie值一起发送给web服务器。例如：Cookie: $Version=1; Skin=new;

* **From：** 发出请求的用户的Email。例如：From: user@email.com

* **Host：** 指定请求资源的Internet主机和端口号，必须表示请求url的原始服务器或网关的位置。HTTP/1.1请求必须包含主机头域，否则系统会以400状态码返回。

* **If-Match：** 只有请求内容与实体相匹配才有效。例如：If-Match: “737060cd8c284d8af7ad3082f209582d”

* **If-Modified-Since：** 如果请求的部分在指定时间之后被修改则请求成功，未被修改则返回304代码。例如：If-Modified-Since: Sat, 29 Oct 2010 19:43:31 GMT

* **If-None-Match：** 如果内容未改变返回304代码，参数为服务器先前发送的Etag，与服务器回应的Etag比较判断是否改变。例如：If-None-Match: "737060cd8c284d8af7ad3082f209582d"

* **If-Range：** 如果实体未改变，服务器发送客户端丢失的部分，否则发送整个实体。参数也为Etag。例如：If-Range: "737060cd8c284d8af7ad3082f209582d"

* **If-Unmodified-Since：** 只在实体在指定时间之后未被修改才请求成功。例如：If-Unmodified-Since: Sat, 29 Oct 2010 19:43:31 GMT

* **Max-Forwards：** 限制信息通过代理和网关传送的时间。例如：Max-Forwards: 10

* **Proxy-Authorization：** 连接到代理的授权证书。例如：Proxy-Authorization: Basic QWxhZGRpbjpvcGVuIHNlc2FtZQ==

* **Range：** 可以请求实体的一个或者多个子范围。如：bytes=0-499表示头500个字节，bytes=500-999 表示第二个500字节，bytes=-500 表示最后500个字节，bytes=500- 表示500字节以后的范围，bytes=0-0,-1 表示第一个和最后一个字节，bytes=500-600,601-999 表示同时指定几个范围。服务器可以忽略此请求头，如果无条件的GET包含Range请求头，响应会以状态码206（PartialContent）返回而不是以200（OK）。

* **Referer：** 这个字段的正确拼写是Referrer，由于早期HTTP规范的拼写错误，为了保持向后兼容就将错就错了。当浏览器向web服务器发送请求的时候，一般会带上Referer，告诉服务器当前的请求是从哪个页面链接过来的，服务器藉此可以获得一些信息用于处理。比如从我主页上链接到一个朋友那里，他的服务器就能够从HTTP Referer中统计出每天有多少用户通过我的主页上的链接访问他的网站。例如：Referer: http://www.zcmhi.com/archives/71.html

* **TE：** 客户端愿意接受的传输编码，并通知服务器接受接受尾加头信息。例如：	TE: trailers,deflate;q=0.5

* **User-Agent：** 发出请求的客户端的信息（浏览器信息）。例如：User-Agent: Mozilla/5.0 (Linux; X11)



### Response响应消息：
```console
# Response响应消息的格式如下
HTTP-VersionSPStatus-CodeSPReason-PhraseCRLF 
```

　　其中SP代表空格，CRLF代表回
下面的样子：
```consle
HTTP-Version Status-Code Reason-Phrase 
...
...

```

　　**Status-Code**是一个三位数的结果代码。可以分为5种。

| 状态码 | 介绍 |  
| :-------- | :-------- |
| 1xx | 信息状态码。表示该请求已经被接受，正在被处理 | 
| 2xx | 正确状态码。表示该请求已经被接受并处理，且没有错误发生。例如200（OK）表示一切正常。 |
| 3xx | 重定向状态码。例如301、302表示该资源已经不存在或者换了地址，客户端需要重新定向到一个信的资源。服务器响应中会附带这个新资源地址。|
| 4xx | 请求错误。401表示没有权限访问、404表示资源不存在、405表示访问方式错误（例如Servlet只接受GET和POST，但是客户端却以DELETE方式访问） |  
| 5xx | 服务器错误。例如500表示程序出现异常而中途停止运行。  

　　**Reason-Phrase**主要用于帮助用户理解。

　　除此之外，响应头还允许服务器传递无法放在状态行的附加信息，它们主要描述服务器的信息和Request-URI进一步的信息。响应头域包含Age、Location、Proxy-Authenticate、Public、Retry-After、Server、Vary、Warning、WWW-Authenticate。对响应头域的扩展要求通讯双方都支持，如果存在不支持的响应头域，一般将会作为实体头域处理。 

　　典型的响应消息：
```console
HTTP/1.0 200 OK 
 Date:Mon,31Dec200104:25:57GMT 
 Server:Apache/1.3.14(Unix) 
 Content-type:text/html 
 Last-modified:Tue,17Apr200106:46:28GMT 
 Etag:"a030f020ac7c01:1e9f" 
 Content-length:39725426 
 Content-range:bytes554554-40279979/40279980 

```

　　响应头域：
* **Accept-Ranges** 表明服务器是否支持指定范围请求及哪种类型的分段请求。例如：Accept-Ranges: bytes

* **Age** 从原始服务器到代理缓存形成的估算时间（以秒计，非负）。例如：Age:12

* **Allow：** 服务器支持哪些请求方法（如GET、POST等）。例如：Allow: GET, POST

* **Proxy-Authenticate** 它指出认证方案和可应用到代理的该URL上的参数。例如：Proxy-Authenticate: Basic

* **Public**        

* **Retry-After** 如果实体暂时不可取，通知客户端在指定时间之后再次尝试。Retry-After: 120

* **Server** WEB 服务器表明自己是什么软件及版本等信息。例如：Server：Apache/2.0.61 (Unix)

* **Vary** WEB服务器用该头部的内容告诉 Cache 服务器，在什么条件下才能用本响应所返回的对象响应后续的请求。假如源WEB服务器在接到第一个请求消息时，其响应消息的头部为：Content-Encoding: gzip; Vary: Content-Encoding，那么Cache服务器会分析后续请求消息的头部，检查其Accept-Encoding，是否跟先前响应的Vary头部值一致，即是否使用相同的内容编码方法，这样就可以防止Cache服务器用自己Cache 里面压缩后的实体响应给不具备解压能力的浏览器。例如：Vary：Accept-Encoding。

* **Warning** 警告实体可能存在的问题。Warning: 199 Miscellaneous warning

* **WWW-Authenticate** 表明客户端请求实体应该使用的授权方案。WWW-Authenticate: Basic

## cookie